name: Agent Builder (Context Aware)

on:
  issue_comment:
    types: [created]

jobs:
  builder:
    if: contains(github.event.comment.body, '/code-zhangxiaohao-agent')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate File Tree
        id: file_tree
        run: |
          TREE=$(find . -maxdepth 5 -not -path '*/.*' -not -path '*/node_modules*' -not -path '*/dist*' -not -path '*/build*' -not -path '*/.next*' | sed 's|./||' | sort)
          echo "TREE<<EOF" >> $GITHUB_ENV
          echo "$TREE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Execute Frontend Implementation
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          PROJECT_TREE: ${{ env.TREE }}
        with:
          script: |
            const projectTree = process.env.PROJECT_TREE;
            const existingFiles = new Set(projectTree.split('\n').filter(f => f.trim()));
            
            // é¡¹ç›®ç»“æ„è§„èŒƒ
            const PROJECT_STRUCTURE = {
              pages: 'frontend/app',
              components: 'frontend/components',
              uiComponents: 'frontend/components/ui',
              featureComponents: 'frontend/components/features',
              hooks: 'frontend/hooks',
              lib: 'frontend/lib',
              types: 'frontend/types',
              validExtensions: ['.tsx', '.ts', '.css', '.json'],
              protectedFiles: ['frontend/app/layout.tsx', 'frontend/app/globals.css', 'frontend/package.json']
            };

            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            const fileExists = async (path) => {
              try {
                await github.rest.repos.getContent({ ...context.repo, path });
                return true;
              } catch (e) {
                return false;
              }
            };

            // è¯»å–æ–‡ä»¶å†…å®¹
            const readFileContent = async (path) => {
              try {
                const { data } = await github.rest.repos.getContent({ ...context.repo, path });
                if (data.size < 80000 && data.content) {
                  return Buffer.from(data.content, 'base64').toString();
                }
              } catch (e) {}
              return null;
            };

            // éªŒè¯è·¯å¾„æ˜¯å¦ç¬¦åˆé¡¹ç›®è§„èŒƒ
            const validatePath = (path) => {
              const errors = [];
              
              // é¡µé¢æ–‡ä»¶å¿…é¡»åœ¨ app/ ç›®å½•
              if (path.includes('/page.tsx') && !path.startsWith('frontend/app/')) {
                errors.push(`é¡µé¢æ–‡ä»¶å¿…é¡»åœ¨ frontend/app/ ç›®å½•: ${path}`);
              }
              
              // ç»„ä»¶ä¸èƒ½ç›´æ¥æ”¾åœ¨ app/ ç›®å½•ï¼ˆé™¤äº† page.tsx, layout.tsx ç­‰ï¼‰
              const appOnlyFiles = ['page.tsx', 'layout.tsx', 'loading.tsx', 'error.tsx', 'not-found.tsx', 'template.tsx'];
              if (path.startsWith('frontend/app/') && path.endsWith('.tsx')) {
                const fileName = path.split('/').pop();
                if (!appOnlyFiles.includes(fileName)) {
                  errors.push(`ç»„ä»¶ä¸åº”æ”¾åœ¨ app/ ç›®å½•ï¼Œåº”æ”¾åœ¨ components/: ${path}`);
                }
              }
              
              // UI ç»„ä»¶åº”æ”¾åœ¨ components/ui/
              if (path.includes('Button') || path.includes('Input') || path.includes('Modal') || path.includes('Dialog')) {
                if (!path.includes('components/ui/') && !path.includes('components/features/')) {
                  errors.push(`UI ç»„ä»¶åº”æ”¾åœ¨ components/ui/ æˆ– components/features/: ${path}`);
                }
              }
              
              return errors;
            };

            // 1. è¯»å–è®¨è®ºè®°å½•
            console.log("ğŸ“¥ è¯»å–è®¨è®ºè®°å½•...");
            const comments = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number
            });
            
            const fullDiscussionText = comments.data.map(c => c.body).join('\n') + '\n' + process.env.ISSUE_BODY;
            const discussionHistory = comments.data
              .map(c => `[User: ${c.user.login}]:\n${c.body}`)
              .join("\n\n---\n\n");

            // 2. è¯»å–çˆ¶çº§è§„èŒƒ
            let contextBody = process.env.ISSUE_BODY;
            const parentRegex = /(?:Parent|Ref|çˆ¶ä»»åŠ¡|çˆ¶çº§|çˆ¶éœ€æ±‚|å…³è”çˆ¶éœ€æ±‚)[\s:ï¼š]+#(\d+)/i;
            const parentMatch = contextBody.match(parentRegex);
            if (parentMatch) {
              try {
                const p = await github.rest.issues.get({ ...context.repo, issue_number: parentMatch[1] });
                contextBody += `\n\n--- [çˆ¶çº§è§„èŒƒ] ---\n${p.data.body}`;
              } catch(e) {}
            }

            // 3. æ™ºèƒ½æ–‡ä»¶è·¯å¾„è¯†åˆ«ï¼ˆå¢å¼ºç‰ˆï¼‰
            console.log("ğŸ” æ‰«æç›¸å…³æ–‡ä»¶...");
            
            // å¤šç§è·¯å¾„æ ¼å¼åŒ¹é…
            const pathPatterns = [
              /(?:frontend|src)\/[\w\-\.\/]+\.(?:tsx|ts|css|json)/g,
              /app\/[\w\-\.\/]+\.(?:tsx|ts)/g,
              /components\/[\w\-\.\/]+\.(?:tsx|ts)/g,
              /hooks\/[\w\-\.\/]+\.(?:tsx|ts)/g,
              /lib\/[\w\-\.\/]+\.(?:tsx|ts)/g
            ];
            
            let foundPaths = new Set();
            for (const pattern of pathPatterns) {
              const matches = fullDiscussionText.match(pattern) || [];
              matches.forEach(p => {
                // æ ‡å‡†åŒ–è·¯å¾„
                let normalized = p;
                if (!normalized.startsWith('frontend/') && !normalized.startsWith('src/')) {
                  normalized = 'frontend/' + normalized;
                }
                foundPaths.add(normalized);
              });
            }
            
            // æ”¶é›†ç°æœ‰æ–‡ä»¶å’Œæ–°æ–‡ä»¶
            const existingFilesContext = [];
            const newFilePaths = [];
            
            for (const path of foundPaths) {
              const exists = await fileExists(path);
              if (exists) {
                const content = await readFileContent(path);
                if (content) {
                  existingFilesContext.push({ path, content, action: 'MODIFY' });
                  console.log(`ğŸ“„ [å­˜åœ¨] ${path}`);
                  
                  // è‡ªåŠ¨å‘ç°å…³è”æ–‡ä»¶ï¼ˆimport è¯­å¥ï¼‰
                  const importRegex = /from\s+['"](@\/|\.\.\/|\.\/)([^'"]+)['"]/g;
                  let match;
                  while ((match = importRegex.exec(content)) !== null) {
                    let importPath = match[2];
                    if (!importPath.endsWith('.tsx') && !importPath.endsWith('.ts')) {
                      importPath += '.tsx';
                    }
                    if (match[1] === '@/') {
                      importPath = 'frontend/' + importPath;
                    }
                    if (!foundPaths.has(importPath)) {
                      const importExists = await fileExists(importPath);
                      if (importExists) {
                        const importContent = await readFileContent(importPath);
                        if (importContent) {
                          existingFilesContext.push({ path: importPath, content: importContent, action: 'REFERENCE' });
                          console.log(`ğŸ“„ [å…³è”] ${importPath}`);
                        }
                      }
                    }
                  }
                }
              } else {
                newFilePaths.push(path);
                console.log(`ğŸ†• [æ–°å»º] ${path}`);
              }
            }

            // 4. è¯»å–å…³é”®ä¸Šä¸‹æ–‡æ–‡ä»¶
            const criticalFiles = ['frontend/app/layout.tsx', 'frontend/app/globals.css'];
            for (const path of criticalFiles) {
              if (!existingFilesContext.find(f => f.path === path)) {
                const content = await readFileContent(path);
                if (content) {
                  existingFilesContext.push({ path, content, action: 'REFERENCE' });
                }
              }
            }

            // è¯»å– package.json
            let packageJsonContent = "{}";
            const pkgPath = await fileExists('frontend/package.json') ? 'frontend/package.json' : 'package.json';
            const pkgContent = await readFileContent(pkgPath);
            if (pkgContent) packageJsonContent = pkgContent;

            // 5. æ„å»ºç»“æ„åŒ– Prompt
            const existingFilesStr = existingFilesContext.map(f => 
              '### ' + f.action + ': ' + f.path + '\n```\n' + f.content + '\n```'
            ).join('\n\n');

            const newFilesList = newFilePaths.length > 0 ? newFilePaths.map(p => '- ' + p).join('\n') : 'æ— ';
            const prompt = 'ä½ æ˜¯ä¸€å Next.js å‰ç«¯ä¸“å®¶ï¼Œè´Ÿè´£æ ¹æ®éœ€æ±‚ç²¾å‡†ä¿®æ”¹æˆ–åˆ›å»ºä»£ç ã€‚\n\n' +
              'ã€é¡¹ç›®ç»“æ„è§„èŒƒã€‘\n' +
              '- é¡µé¢æ–‡ä»¶: frontend/app/[route]/page.tsx\n' +
              '- å¸ƒå±€æ–‡ä»¶: frontend/app/[route]/layout.tsx\n' +
              '- é€šç”¨ç»„ä»¶: frontend/components/ui/\n' +
              '- ä¸šåŠ¡ç»„ä»¶: frontend/components/features/\n' +
              '- Hooks: frontend/hooks/\n' +
              '- å·¥å…·å‡½æ•°: frontend/lib/utils/\n' +
              '- ç±»å‹å®šä¹‰: frontend/types/\n\n' +
              'ã€å½“å‰ç›®å½•ç»“æ„ã€‘\n' +
              projectTree + '\n\n' +
              'ã€ç°æœ‰æ–‡ä»¶å†…å®¹ã€‘\n' +
              'ä»¥ä¸‹æ–‡ä»¶å·²å­˜åœ¨äºé¡¹ç›®ä¸­ï¼š\n' +
              existingFilesStr + '\n\n' +
              'ã€å¾…åˆ›å»ºæ–‡ä»¶è·¯å¾„ã€‘\n' +
              'ä»¥ä¸‹è·¯å¾„è¢«æåŠä½†ä¸å­˜åœ¨ï¼Œéœ€è¦æ–°å»ºï¼š\n' +
              newFilesList + '\n\n' +
              'ã€package.jsonã€‘\n' +
              packageJsonContent + '\n\n' +
              'ã€éœ€æ±‚ã€‘\n' +
              'æ ‡é¢˜ï¼š' + process.env.ISSUE_TITLE + '\n' +
              'æè¿°ï¼š' + contextBody + '\n' +
              'è®¨è®ºï¼š' + discussionHistory + '\n\n' +
              'ã€æ“ä½œè§„åˆ™ã€‘\n' +
              '1. **MODIFYï¼ˆä¿®æ”¹ç°æœ‰æ–‡ä»¶ï¼‰**ï¼š\n' +
              '   - åŸºäºç°æœ‰ä»£ç å¢é‡ä¿®æ”¹\n' +
              '   - ä¿ç•™æ‰€æœ‰ä¸æœ¬æ¬¡éœ€æ±‚æ— å…³çš„ä»£ç \n' +
              '   - ä¿ç•™æ‰€æœ‰ç°æœ‰ import è¯­å¥\n' +
              '   - ä¿ç•™æ‰€æœ‰ç°æœ‰å‡½æ•°å’Œç»„ä»¶\n' +
              '   - åªæ·»åŠ æˆ–ä¿®æ”¹éœ€æ±‚ç›¸å…³çš„éƒ¨åˆ†\n' +
              '   - è¾“å‡ºå®Œæ•´çš„å¯è¿è¡Œä»£ç \n\n' +
              '2. **CREATEï¼ˆåˆ›å»ºæ–°æ–‡ä»¶ï¼‰**ï¼š\n' +
              '   - åªæœ‰åœ¨æ–‡ä»¶ä¸å­˜åœ¨æ—¶æ‰èƒ½åˆ›å»º\n' +
              '   - é¡µé¢å¿…é¡»æ”¾åœ¨ frontend/app/[route]/page.tsx\n' +
              '   - ç»„ä»¶å¿…é¡»æ”¾åœ¨ frontend/components/ ä¸‹\n' +
              '   - æ£€æŸ¥æ˜¯å¦æœ‰å¯å¤ç”¨çš„ç°æœ‰ç»„ä»¶\n\n' +
              '3. **ç¦æ­¢æ“ä½œ**ï¼š\n' +
              '   - ç¦æ­¢åˆ é™¤ç°æœ‰ä»£ç \n' +
              '   - ç¦æ­¢é‡å†™å·²å­˜åœ¨çš„æ–‡ä»¶ï¼ˆåªèƒ½ä¿®æ”¹ï¼‰\n' +
              '   - ç¦æ­¢åœ¨ app/ ç›®å½•åˆ›å»ºéé¡µé¢ç»„ä»¶\n' +
              '   - ç¦æ­¢åˆ›å»ºä¸ç°æœ‰ç»„ä»¶åŠŸèƒ½é‡å¤çš„æ–°ç»„ä»¶\n\n' +
              'ã€è¾“å‡ºæ ¼å¼ã€‘\n' +
              'æ¯ä¸ªæ–‡ä»¶ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼Œå¿…é¡»æ ‡æ˜æ“ä½œç±»å‹ï¼š\n\n' +
              '### MODIFY: frontend/app/xxx/page.tsx\n' +
              '```tsx\n' +
              '(å®Œæ•´çš„ä¿®æ”¹åä»£ç )\n' +
              '```\n\n' +
              '### CREATE: frontend/components/features/xxx.tsx\n' +
              '```tsx\n' +
              '(æ–°æ–‡ä»¶çš„å®Œæ•´ä»£ç )\n' +
              '```\n\n' +
              'å¦‚éœ€æ–°å¢ä¾èµ–ï¼š\n' +
              '### MODIFY: frontend/package.json\n' +
              '```json\n' +
              '(å®Œæ•´çš„ package.json)\n' +
              '```';

            console.log("ğŸ¤– è°ƒç”¨ AI...");

            const aiRes = await fetch('https://openrouter.ai/api/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: "anthropic/claude-sonnet-4-20250514",
                messages: [{ role: "user", content: prompt }],
                max_tokens: 16000
              })
            });
            
            if (!aiRes.ok) {
              const errText = await aiRes.text();
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: `âŒ AI API è°ƒç”¨å¤±è´¥: ${errText.substring(0, 500)}`
              });
              throw new Error(`AI API Error: ${errText}`);
            }
            
            const aiData = await aiRes.json();
            const rawContent = aiData.choices[0].message.content;

            // 6. è§£æ AI è¾“å‡º
            console.log("ğŸ“¦ è§£ææ–‡ä»¶...");
            const files = [];
            const lines = rawContent.split('\n');
            let currentFile = null;
            let currentAction = null;
            let currentContentLines = [];
            let inCodeBlock = false;

            const cleanContent = (linesArray) => {
              let content = linesArray.join('\n').trim();
              // ç§»é™¤ä»£ç å—æ ‡è®°
              content = content.replace(/^```[\w\-\.]*\s*$/gm, '');
              content = content.replace(/^```\s*$/gm, '');
              return content.trim();
            };

            for (const line of lines) {
              const modifyMatch = line.trim().match(/^###\s*MODIFY:\s*(.+)$/);
              const createMatch = line.trim().match(/^###\s*CREATE:\s*(.+)$/);
              const fileMatch = line.trim().match(/^###\s*FILE:\s*(.+)$/);
              
              if (modifyMatch || createMatch || fileMatch) {
                if (currentFile) {
                  files.push({ 
                    path: currentFile, 
                    content: cleanContent(currentContentLines),
                    action: currentAction 
                  });
                }
                currentFile = (modifyMatch || createMatch || fileMatch)[1].trim();
                currentAction = modifyMatch ? 'MODIFY' : (createMatch ? 'CREATE' : 'UNKNOWN');
                currentContentLines = [];
                inCodeBlock = false;
              } else {
                currentContentLines.push(line);
              }
            }
            
            if (currentFile) {
              files.push({ 
                path: currentFile, 
                content: cleanContent(currentContentLines),
                action: currentAction 
              });
            }

            if (files.length === 0) {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: `âŒ AI æœªç”Ÿæˆæœ‰æ•ˆçš„æ–‡ä»¶å—ï¼Œè¯·æ£€æŸ¥éœ€æ±‚æè¿°æ˜¯å¦æ¸…æ™°ã€‚`
              });
              throw new Error("è§£æå¤±è´¥ï¼šAI æœªç”Ÿæˆä»»ä½•æœ‰æ•ˆæ–‡ä»¶å—");
            }

            // 7. éªŒè¯å’Œè¿‡æ»¤æ–‡ä»¶
            const validFiles = [];
            const warnings = [];
            
            for (const file of files) {
              // è·³è¿‡åç«¯æ–‡ä»¶
              if (file.path.endsWith('.go') || file.path.includes('backend/')) continue;
              
              // éªŒè¯è·¯å¾„
              const pathErrors = validatePath(file.path);
              if (pathErrors.length > 0) {
                warnings.push(...pathErrors);
              }
              
              // JSON æ ¡éªŒ
              if (file.path.endsWith('.json')) {
                try { 
                  JSON.parse(file.content); 
                } catch (e) { 
                  warnings.push(`JSON è¯­æ³•é”™è¯¯: ${file.path}`);
                  continue; 
                }
              }
              
              // æ£€æŸ¥ CREATE æ“ä½œçš„æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
              if (file.action === 'CREATE') {
                const exists = await fileExists(file.path);
                if (exists) {
                  warnings.push(`æ–‡ä»¶å·²å­˜åœ¨ï¼ŒCREATE æ“ä½œæ”¹ä¸º MODIFY: ${file.path}`);
                  file.action = 'MODIFY';
                }
              }
              
              // æ£€æŸ¥å—ä¿æŠ¤æ–‡ä»¶
              if (PROJECT_STRUCTURE.protectedFiles.includes(file.path) && file.action === 'CREATE') {
                warnings.push(`å—ä¿æŠ¤æ–‡ä»¶ä¸èƒ½è¢«è¦†ç›–åˆ›å»º: ${file.path}`);
                file.action = 'MODIFY';
              }
              
              // å†…å®¹ä¸èƒ½ä¸ºç©º
              if (!file.content || file.content.trim().length === 0) {
                warnings.push(`æ–‡ä»¶å†…å®¹ä¸ºç©ºï¼Œè·³è¿‡: ${file.path}`);
                continue;
              }
              
              validFiles.push(file);
            }

            // 8. åˆ›å»ºåˆ†æ”¯å¹¶å†™å…¥æ–‡ä»¶
            const branchName = `zhangxiaohao/issue-${context.issue.number}`;
            const baseRef = await github.rest.git.getRef({ ...context.repo, ref: 'heads/main' });
            
            try { 
              await github.rest.git.createRef({ 
                ...context.repo, 
                ref: `refs/heads/${branchName}`, 
                sha: baseRef.data.object.sha 
              }); 
            } catch (e) {
              // åˆ†æ”¯å·²å­˜åœ¨ï¼Œæ›´æ–°åˆ°æœ€æ–° main
              try {
                await github.rest.git.updateRef({
                  ...context.repo,
                  ref: `heads/${branchName}`,
                  sha: baseRef.data.object.sha,
                  force: true
                });
              } catch (e2) {}
            }

            const createdFiles = [];
            const modifiedFiles = [];
            
            for (const file of validFiles) {
              console.log(`ğŸ“ ${file.action}: ${file.path}`);
              
              let sha;
              try {
                const { data } = await github.rest.repos.getContent({ 
                  ...context.repo, 
                  path: file.path, 
                  ref: branchName 
                });
                sha = data.sha;
              } catch (e) {} 
              
              await github.rest.repos.createOrUpdateFileContents({
                ...context.repo,
                path: file.path,
                message: `${file.action === 'CREATE' ? 'feat' : 'refactor'}(fe): ${file.action.toLowerCase()} ${file.path.split('/').pop()}`,
                content: Buffer.from(file.content).toString('base64'),
                branch: branchName,
                sha: sha
              });
              
              if (file.action === 'CREATE') {
                createdFiles.push(file.path);
              } else {
                modifiedFiles.push(file.path);
              }
            }

            // 9. åˆ›å»º PR
            let prBody = '### ğŸ“¦ å˜æ›´æ¸…å•\n\n';
            if (createdFiles.length > 0) {
              prBody += '**æ–°å»ºæ–‡ä»¶ï¼š**\n' + createdFiles.map(f => '- `' + f + '`').join('\n') + '\n';
            }
            if (modifiedFiles.length > 0) {
              prBody += '**ä¿®æ”¹æ–‡ä»¶ï¼š**\n' + modifiedFiles.map(f => '- `' + f + '`').join('\n') + '\n';
            }
            if (warnings.length > 0) {
              prBody += '\n### âš ï¸ è­¦å‘Š\n' + warnings.map(w => '- ' + w).join('\n');
            }
            prBody += '\n\n---\næŒ‡ä»¤: `/code-zhangxiaohao-agent`\nIssue: #' + context.issue.number;

            try {
              const pr = await github.rest.pulls.create({
                ...context.repo,
                title: `[FE] ${process.env.ISSUE_TITLE}`,
                head: branchName,
                base: 'main',
                body: prBody
              });
              
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: `PR: ${pr.data.html_url}\n\næ–°å»º: ${createdFiles.length} | ä¿®æ”¹: ${modifiedFiles.length}${warnings.length > 0 ? `\n\nâš ï¸ ${warnings.length} ä¸ªè­¦å‘Šï¼Œè¯¦è§ PR` : ''}`
              });
            } catch(e) {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: `åˆ†æ”¯å·²æ›´æ–°: \`${branchName}\`\n\næ–°å»º: ${createdFiles.length} | ä¿®æ”¹: ${modifiedFiles.length}`
              });
            }