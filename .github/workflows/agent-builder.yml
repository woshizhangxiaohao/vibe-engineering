name: Agent Builder (Context Aware)

on:
  issue_comment:
    types: [created]

jobs:
  builder:
    if: contains(github.event.comment.body, '/code-zhangxiaohao-agent')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate File Tree
        id: file_tree
        run: |
          TREE=$(find . -maxdepth 5 -not -path '*/.*' -not -path '*/node_modules*' -not -path '*/dist*' -not -path '*/build*' -not -path '*/.next*' | sed 's|./||' | sort)
          echo "TREE<<EOF" >> $GITHUB_ENV
          echo "$TREE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Execute Frontend Implementation
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          PROJECT_TREE: ${{ env.TREE }}
        with:
          script: |
            const projectTree = process.env.PROJECT_TREE;
            const existingFiles = new Set(projectTree.split('\n').filter(f => f.trim()));
            
            // é¡¹ç›®ç»“æ„è§„èŒƒ
            const PROJECT_STRUCTURE = {
              pages: 'frontend/app',
              components: 'frontend/components',
              uiComponents: 'frontend/components/ui',
              featureComponents: 'frontend/components/features',
              hooks: 'frontend/hooks',
              lib: 'frontend/lib',
              types: 'frontend/types',
              validExtensions: ['.tsx', '.ts', '.css', '.json'],
              protectedFiles: ['frontend/app/layout.tsx', 'frontend/app/globals.css', 'frontend/package.json']
            };

            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆæ”¯æŒæŒ‡å®šåˆ†æ”¯ï¼‰
            const fileExists = async (path, branch = null) => {
              try {
                const params = { ...context.repo, path };
                if (branch) {
                  params.ref = branch;
                }
                await github.rest.repos.getContent(params);
                return true;
              } catch (e) {
                return false;
              }
            };

            // è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆæ”¯æŒæŒ‡å®šåˆ†æ”¯ï¼‰
            const readFileContent = async (path, branch = null) => {
              try {
                const params = { ...context.repo, path };
                if (branch) {
                  params.ref = branch;
                }
                const { data } = await github.rest.repos.getContent(params);
                if (data.size < 80000 && data.content) {
                  return Buffer.from(data.content, 'base64').toString();
                }
              } catch (e) {}
              return null;
            };

            // éªŒè¯è·¯å¾„æ˜¯å¦ç¬¦åˆé¡¹ç›®è§„èŒƒï¼ˆæ”¯æŒçˆ¶çº§è§„èŒƒè¦†ç›–ï¼‰
            const validatePath = (path, parentSpecText = '') => {
              const errors = [];
              
              // æ£€æŸ¥è·¯å¾„æ˜¯å¦åœ¨çˆ¶çº§è§„èŒƒä¸­è¢«æ˜ç¡®æåŠï¼ˆå¦‚æœæ˜¯ï¼Œåˆ™å…è®¸ï¼‰
              const isInParentSpec = parentSpecText && (
                parentSpecText.includes(path) || 
                parentSpecText.includes(path.replace('frontend/', ''))
              );
              
              // é¡µé¢æ–‡ä»¶å¿…é¡»åœ¨ app/ ç›®å½•
              if (path.includes('/page.tsx') && !path.startsWith('frontend/app/')) {
                if (!isInParentSpec) {
                  errors.push(`é¡µé¢æ–‡ä»¶å¿…é¡»åœ¨ frontend/app/ ç›®å½•: ${path}`);
                }
              }
              
              // ç»„ä»¶ä¸èƒ½ç›´æ¥æ”¾åœ¨ app/ ç›®å½•ï¼ˆé™¤äº† page.tsx, layout.tsx ç­‰ï¼‰
              const appOnlyFiles = ['page.tsx', 'layout.tsx', 'loading.tsx', 'error.tsx', 'not-found.tsx', 'template.tsx'];
              if (path.startsWith('frontend/app/') && path.endsWith('.tsx')) {
                const fileName = path.split('/').pop();
                if (!appOnlyFiles.includes(fileName) && !isInParentSpec) {
                  errors.push(`ç»„ä»¶ä¸åº”æ”¾åœ¨ app/ ç›®å½•ï¼Œåº”æ”¾åœ¨ components/: ${path}`);
                }
              }
              
              // UI ç»„ä»¶åº”æ”¾åœ¨ components/ui/
              if (path.includes('Button') || path.includes('Input') || path.includes('Modal') || path.includes('Dialog')) {
                if (!path.includes('components/ui/') && !path.includes('components/features/') && !isInParentSpec) {
                  errors.push(`UI ç»„ä»¶åº”æ”¾åœ¨ components/ui/ æˆ– components/features/: ${path}`);
                }
              }
              
              return errors;
            };

            // 1. è¯»å–å½“å‰ issue çš„è¯„è®º
            console.log("ğŸ“¥ è¯»å–å½“å‰ issue çš„è¯„è®º...");
            const comments = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number
            });
            
            // è¯†åˆ«å‰ç«¯è§„èŒƒå’Œå‰ç«¯æ–¹æ¡ˆçš„æ ‡è®°ï¼ˆæ”¾å®½åŒ¹é…ï¼ŒåŒ…å«"è§„èŒƒ"å…³é”®è¯å³å¯ï¼‰
            const frontendSpecMarkers = [
              /è§„èŒƒ/i,
              /å‰ç«¯è§„èŒƒ/i,
              /å‰ç«¯çº¦æŸ/i,
              /frontend spec/i,
              /frontend constraint/i,
              /\[å‰ç«¯è§„èŒƒ\]/i,
              /\[å‰ç«¯çº¦æŸ\]/i,
              /## å‰ç«¯è§„èŒƒ/i,
              /## å‰ç«¯çº¦æŸ/i
            ];
            
            const frontendPlanMarkers = [
              /å‰ç«¯å®æ–½æ–¹æ¡ˆ/i,
              /å‰ç«¯å®æ–½è®¡åˆ’/i,
              /æ–¹æ¡ˆ/i,
              /frontend implementation plan/i,
              /frontend implementation/i
            ];
            
            // è¯†åˆ«åˆ†æ”¯ç­–ç•¥çš„æ ‡è®°
            const branchMarkers = [
              /ä½¿ç”¨åˆ†æ”¯[\s:ï¼š]+([^\s\n]+)/i,
              /åœ¨åˆ†æ”¯[\s:ï¼š]+([^\s\n]+)/i,
              /åˆ†æ”¯[\s:ï¼š]+([^\s\n]+)/i,
              /branch[\s:ï¼š]+([^\s\n]+)/i,
              /ä½¿ç”¨[\s:ï¼š]+([^\s\n]+)\s*åˆ†æ”¯/i,
              /åŸºäº[\s:ï¼š]+([^\s\n]+)\s*åˆ†æ”¯/i,
              /zhangxiaohao\/issue-(\d+)/i
            ];
            
            // ä»å½“å‰ issue çš„è¯„è®ºä¸­æå–å‰ç«¯è§„èŒƒã€å‰ç«¯æ–¹æ¡ˆå’Œåˆ†æ”¯ä¿¡æ¯
            let frontendSpec = '';
            let frontendPlan = '';
            let branchFromComment = null; // ä»è¯„è®ºä¸­æå–çš„åˆ†æ”¯ä¿¡æ¯
            const referencedContent = []; // å­˜å‚¨å¼•ç”¨çš„å†…å®¹
            
            // æ‰¾åˆ°è§¦å‘è¯„è®ºï¼ˆåŒ…å« /code-zhangxiaohao-agent çš„è¯„è®ºï¼‰
            const triggerComment = comments.data.find(c => c.body.includes('/code-zhangxiaohao-agent'));
            
            // ç›´æ¥ä»è§¦å‘è¯„è®ºä¸­æå–æ‰€æœ‰é“¾æ¥å¹¶è¯»å–å†…å®¹
            if (triggerComment) {
              // åŒ¹é…æ‰€æœ‰ GitHub URL
              const urlPattern = /https:\/\/github\.com\/[^\s\)]+/g;
              const urls = triggerComment.body.match(urlPattern) || [];
              
              for (const url of urls) {
                try {
                  console.log('ğŸ“ è¯»å–é“¾æ¥: ' + url);
                  
                  // å°è¯•è§£æ URL ç±»å‹å¹¶è¯»å–å†…å®¹
                  let content = '';
                  let source = url;
                  
                  // å¦‚æœæ˜¯è¯„è®ºé“¾æ¥
                  const commentMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)\/issues\/\d+#issuecomment-(\d+)/);
                  if (commentMatch) {
                    const comment = await github.rest.issues.getComment({
                      owner: commentMatch[1],
                      repo: commentMatch[2],
                      comment_id: parseInt(commentMatch[3])
                    });
                    content = comment.data.body;
                    source = commentMatch[1] + '/' + commentMatch[2] + ' Comment';
                  }
                  // å¦‚æœæ˜¯ Issue é“¾æ¥
                  else if (url.includes('/issues/')) {
                    const issueMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/);
                    if (issueMatch) {
                      const issue = await github.rest.issues.get({
                        owner: issueMatch[1],
                        repo: issueMatch[2],
                        issue_number: parseInt(issueMatch[3])
                      });
                      content = issue.data.body || '';
                      source = issueMatch[1] + '/' + issueMatch[2] + ' Issue #' + issueMatch[3];
                    }
                  }
                  
                  if (content) {
                    referencedContent.push({
                      source: source,
                      url: url,
                      content: content
                    });
                    console.log('âœ… å·²è¯»å–: ' + url);
                  }
                } catch(e) {
                  console.log('âš ï¸ è¯»å–å¤±è´¥: ' + url + ' - ' + e.message);
                }
              }
            }
            
            // åªåœ¨è§¦å‘è¯„è®ºä¸­æå–è§„èŒƒå’Œæ–¹æ¡ˆä¿¡æ¯
            if (triggerComment) {
              const hasSpec = frontendSpecMarkers.some(marker => marker.test(triggerComment.body));
              const hasPlan = frontendPlanMarkers.some(marker => marker.test(triggerComment.body));
              
              // æ£€æŸ¥æ˜¯å¦åŒ…å«åˆ†æ”¯ä¿¡æ¯
              let branchMatch = null;
              for (const marker of branchMarkers) {
                const match = triggerComment.body.match(marker);
                if (match) {
                  branchMatch = match;
                  break;
                }
              }
              
              if (hasSpec) {
                frontendSpec = triggerComment.body;
                console.log(`ğŸ“‹ å‘ç°å‰ç«¯è§„èŒƒ: ${triggerComment.html_url}`);
              }
              if (hasPlan) {
                frontendPlan = triggerComment.body;
                console.log(`ğŸ“‹ å‘ç°å‰ç«¯æ–¹æ¡ˆ: ${triggerComment.html_url}`);
              }
              if (branchMatch) {
                const branchValue = branchMatch[1].trim();
                if (/^\d+$/.test(branchValue)) {
                  branchFromComment = `zhangxiaohao/issue-${branchValue}`;
                } else if (branchValue.startsWith('zhangxiaohao/issue-')) {
                  branchFromComment = branchValue;
                } else {
                  branchFromComment = branchValue;
                }
                console.log(`ğŸ”— ä»è¯„è®ºä¸­å‘ç°åˆ†æ”¯ä¿¡æ¯: ${branchFromComment} (${triggerComment.html_url})`);
              }
            }
            
            // æ”¶é›†è§¦å‘è¯„è®ºå†…å®¹ï¼ˆç”¨äº ISSUE_COMMENTS å˜é‡ï¼‰
            const triggerCommentContent = triggerComment ? triggerComment.body : '';
            
            // æ£€æµ‹æ˜¯å¦æ˜¯ä¿®å¤ bug çš„åœºæ™¯
            const isBugFix = triggerCommentContent && (
              /ä¿®å¤|bug|fix|é”™è¯¯|é—®é¢˜|issue/i.test(triggerCommentContent) ||
              /ä¿®å¤äº†|fixed|è§£å†³äº†/i.test(triggerCommentContent)
            );
            
            // æ”¶é›†å…¶ä»–è¯„è®ºä½œä¸ºè®¨è®ºå†å²ï¼ˆæ’é™¤è§¦å‘è¯„è®ºï¼Œç”¨äºå‘åå…¼å®¹ï¼‰
            const generalComments = comments.data
              .filter(c => !c.body.includes('/code-zhangxiaohao-agent'))
              .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
            
            const discussionHistory = generalComments
              .map(c => `[User: ${c.user.login}]:\n${c.body}`)
              .join("\n\n---\n\n");
            
            // åˆå¹¶æ‰€æœ‰æ–‡æœ¬æ¥æºï¼ˆç”¨äºæ–‡ä»¶è·¯å¾„è¯†åˆ«ï¼‰
            const fullDiscussionText = comments.data.map(c => c.body).join('\n') + '\n' + process.env.ISSUE_BODY;
            let contextBody = process.env.ISSUE_BODY;
            
            // æ·»åŠ è§¦å‘è¯„è®ºçš„å®Œæ•´å†…å®¹ï¼ˆè®© LLM è‡ªå·±åˆ†æï¼‰
            if (triggerComment) {
              contextBody += '\n\n--- [è§¦å‘è¯„è®º] ---\n';
              contextBody += 'ä»¥ä¸‹æ˜¯è§¦å‘å‘½ä»¤çš„è¯„è®ºå†…å®¹ï¼Œè¯·æ ¹æ®å†…å®¹åˆ¤æ–­å…¶ç”¨é€”ï¼ˆå¯èƒ½åŒ…å«éœ€æ±‚ã€è§„èŒƒã€æ–¹æ¡ˆæˆ–å…¶ä»–ä¿¡æ¯ï¼‰ï¼š\n\n';
              contextBody += triggerComment.body + '\n';
            }
            
            if (frontendSpec) {
              contextBody += '\n\n--- [å‰ç«¯è§„èŒƒ] ---\n' + frontendSpec;
            }
            if (frontendPlan) {
              contextBody += '\n\n--- [å‰ç«¯æ–¹æ¡ˆ] ---\n' + frontendPlan;
            }
            
            // æ·»åŠ å¼•ç”¨çš„å†…å®¹åˆ°ä¸Šä¸‹æ–‡ï¼ˆè®© LLM è‡ªå·±åˆ¤æ–­ç”¨é€”ï¼‰
            if (referencedContent.length > 0) {
              contextBody += '\n\n--- [å¼•ç”¨çš„å†…å®¹] ---\n';
              contextBody += 'ä»¥ä¸‹æ˜¯è§¦å‘è¯„è®ºä¸­å¼•ç”¨çš„å…¶ä»–è¯„è®ºå†…å®¹ï¼Œè¯·æ ¹æ®å†…å®¹åˆ¤æ–­å…¶ç”¨é€”ï¼ˆå¯èƒ½æ˜¯è§„èŒƒã€æ–¹æ¡ˆæˆ–å…¶ä»–ä¿¡æ¯ï¼‰ï¼š\n\n';
              referencedContent.forEach((ref, i) => {
                contextBody += '### å¼•ç”¨ ' + (i + 1) + ': ' + ref.source + '\n';
                contextBody += 'æ¥æº: ' + ref.url + '\n';
                contextBody += 'å†…å®¹:\n' + ref.content + '\n\n';
              });
            }

            // 2. è¯»å–çˆ¶çº§ issue åŸºæœ¬ä¿¡æ¯ï¼Œå¦‚æœå½“å‰ issue æ²¡æœ‰å‰ç«¯è§„èŒƒå’Œå‰ç«¯æ–¹æ¡ˆï¼Œåˆ™ä»çˆ¶çº§ issue çš„è¯„è®ºä¸­æå–
            let parentSpec = '';
            const parentRegex = /(?:Parent|Ref|çˆ¶ä»»åŠ¡|çˆ¶çº§|çˆ¶éœ€æ±‚|å…³è”çˆ¶éœ€æ±‚)[\s:ï¼š]+#(\d+)/i;
            const parentMatch = contextBody.match(parentRegex) || process.env.ISSUE_BODY.match(parentRegex);
            
            if (parentMatch) {
              try {
                const parentId = parentMatch[1];
                console.log(`ğŸ”— è¯»å–çˆ¶çº§ issue: #${parentId}`);
                
                // è¯»å–çˆ¶çº§ issue çš„åŸºæœ¬ä¿¡æ¯ï¼ˆbodyï¼‰
                const p = await github.rest.issues.get({ ...context.repo, issue_number: parentId });
                parentSpec = p.data.body || '';
                
                // å¦‚æœå½“å‰ issue çš„è¯„è®ºä¸­æ²¡æœ‰å‰ç«¯è§„èŒƒå’Œå‰ç«¯æ–¹æ¡ˆï¼Œåˆ™ä»çˆ¶çº§ issue çš„è¯„è®ºä¸­æå–
                if (!frontendSpec && !frontendPlan) {
                  console.log(`ğŸ“‹ å½“å‰ issue æ²¡æœ‰å‰ç«¯è§„èŒƒå’Œå‰ç«¯æ–¹æ¡ˆï¼Œå°è¯•ä»çˆ¶çº§ issue è¯„è®ºä¸­æå–...`);
                  
                  // è¯»å–çˆ¶çº§ issue çš„è¯„è®º
                  const parentComments = await github.rest.issues.listComments({
                    ...context.repo,
                    issue_number: parentId
                  });
                  
                  // æŒ‰æ—¶é—´æ’åºï¼ˆæœ€æ—©çš„åœ¨å‰ï¼‰
                  const sortedParentComments = parentComments.data.sort((a, b) => 
                    new Date(a.created_at) - new Date(b.created_at)
                  );
                  
                  sortedParentComments.forEach(comment => {
                    const hasSpec = frontendSpecMarkers.some(marker => marker.test(comment.body));
                    const hasPlan = frontendPlanMarkers.some(marker => marker.test(comment.body));
                    
                    if (hasSpec && !frontendSpec) {
                      // æå–çˆ¶çº§å‰ç«¯è§„èŒƒï¼ˆåé¢çš„ä¼šè¦†ç›–å‰é¢çš„ï¼‰
                      frontendSpec = comment.body;
                      console.log(`ğŸ“‹ ä»çˆ¶çº§ issue å‘ç°å‰ç«¯è§„èŒƒ: ${comment.html_url}`);
                    } else if (hasPlan && !frontendPlan) {
                      // æå–çˆ¶çº§å‰ç«¯æ–¹æ¡ˆï¼ˆåé¢çš„ä¼šè¦†ç›–å‰é¢çš„ï¼‰
                      frontendPlan = comment.body;
                      console.log(`ğŸ“‹ ä»çˆ¶çº§ issue å‘ç°å‰ç«¯æ–¹æ¡ˆ: ${comment.html_url}`);
                    }
                  });
                  
                  // æ›´æ–° contextBodyï¼ˆå¦‚æœä»çˆ¶çº§æå–åˆ°äº†è§„èŒƒå’Œæ–¹æ¡ˆï¼‰
                  if (frontendSpec) {
                    contextBody += '\n\n--- [å‰ç«¯è§„èŒƒï¼ˆæ¥è‡ªçˆ¶çº§ Issueï¼‰] ---\n' + frontendSpec;
                  }
                  if (frontendPlan) {
                    contextBody += '\n\n--- [å‰ç«¯æ–¹æ¡ˆï¼ˆæ¥è‡ªçˆ¶çº§ Issueï¼‰] ---\n' + frontendPlan;
                  }
                }
                
                if (parentSpec) {
                  contextBody += '\n\n--- [çˆ¶çº§ Issue åŸºæœ¬ä¿¡æ¯] ---\n' + parentSpec;
                  console.log(`âœ… å·²è¯»å–çˆ¶çº§ issue åŸºæœ¬ä¿¡æ¯ï¼Œé•¿åº¦: ${parentSpec.length} å­—ç¬¦`);
                }
              } catch(e) {
                console.log(`âš ï¸ è¯»å–çˆ¶çº§ issue å¤±è´¥: ${e.message}`);
              }
            }

            // 5.5. ç¡®å®šåˆ†æ”¯åï¼ˆä¼˜å…ˆçº§ï¼šè¯„è®ºä¸­çš„åˆ†æ”¯ä¿¡æ¯ > å½“å‰issueåˆ†æ”¯ï¼‰
            // éœ€è¦å…ˆç¡®å®šåˆ†æ”¯ï¼Œæ‰èƒ½ä»æ­£ç¡®çš„åˆ†æ”¯è¯»å–æ–‡ä»¶å†…å®¹
            let branchName = `zhangxiaohao/issue-${context.issue.number}`;
            
            // ä¼˜å…ˆçº§1ï¼šå¦‚æœè¯„è®ºä¸­æŒ‡å®šäº†åˆ†æ”¯ï¼Œä½¿ç”¨è¯„è®ºä¸­çš„åˆ†æ”¯
            if (branchFromComment) {
              branchName = branchFromComment;
              console.log(`ğŸ”— ä½¿ç”¨è¯„è®ºä¸­æŒ‡å®šçš„åˆ†æ”¯: ${branchName}`);
            } else {
              // ä¼˜å…ˆçº§2ï¼šä½¿ç”¨å½“å‰issueçš„åˆ†æ”¯ï¼ˆé»˜è®¤ï¼‰
              console.log(`ğŸ”— ä½¿ç”¨å½“å‰issueçš„åˆ†æ”¯: ${branchName}`);
            }
            
            // æ£€æŸ¥æ–‡ä»¶åœ¨å½“å‰åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            const fileExistsInBranch = async (path, branch) => {
              try {
                await github.rest.repos.getContent({ 
                  ...context.repo, 
                  path,
                  ref: branch
                });
                return true;
              } catch (e) {
                return false;
              }
            };
            
            // 3. æ–‡ä»¶è·¯å¾„è¯†åˆ«å’Œè¯»å–
            console.log("ğŸ” æ‰«æç›¸å…³æ–‡ä»¶...");
            
            const existingFilesContext = [];
            const newFilePaths = [];
            let foundPaths = new Set();
            
            // å¦‚æœæ˜¯ä¿®å¤ bugï¼Œç›´æ¥è¯»å–å½“å‰åˆ†æ”¯ä¸­çš„æ‰€æœ‰å‰ç«¯æ–‡ä»¶ï¼Œè®©å¤§æ¨¡å‹è‡ªå·±åˆ¤æ–­
            if (isBugFix) {
              console.log('ğŸ“‹ ä¿®å¤æ“ä½œï¼šè¯»å–å½“å‰åˆ†æ”¯ä¸­çš„å‰ç«¯æ–‡ä»¶ï¼Œè®©å¤§æ¨¡å‹åˆ¤æ–­éœ€è¦ä¿®æ”¹å“ªäº›æ–‡ä»¶');
              
              try {
                const branchRef = await github.rest.git.getRef({
                  ...context.repo,
                  ref: `heads/${branchName}`
                });
                const commit = await github.rest.git.getCommit({
                  ...context.repo,
                  commit_sha: branchRef.data.object.sha
                });
                const tree = await github.rest.git.getTree({
                  ...context.repo,
                  tree_sha: commit.data.tree.sha,
                  recursive: true
                });
                
                // ç­›é€‰å‰ç«¯æ–‡ä»¶ï¼ˆ.tsx, .tsï¼‰ï¼Œæœ€å¤šè¯»å– 50 ä¸ªæ–‡ä»¶
                const frontendFiles = tree.data.tree
                  .filter(item => item.type === 'blob' && 
                    (item.path.startsWith('frontend/') || item.path.startsWith('src/')) &&
                    (item.path.endsWith('.tsx') || item.path.endsWith('.ts')) &&
                    !item.path.includes('node_modules') &&
                    !item.path.includes('.next') &&
                    !item.path.includes('dist') &&
                    !item.path.includes('test') &&
                    !item.path.includes('spec'))
                  .slice(0, 50)
                  .map(item => item.path);
                
                console.log(`ğŸ“‹ æ‰¾åˆ° ${frontendFiles.length} ä¸ªå‰ç«¯æ–‡ä»¶ï¼Œå°†å…¨éƒ¨æä¾›ç»™å¤§æ¨¡å‹åˆ¤æ–­`);
                
                // å°†æ‰€æœ‰å‰ç«¯æ–‡ä»¶æ·»åŠ åˆ° foundPaths
                frontendFiles.forEach(path => foundPaths.add(path));
              } catch (e) {
                console.log(`âš ï¸ è¯»å–åˆ†æ”¯æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ${e.message}`);
              }
            } else {
              // éä¿®å¤æ“ä½œï¼šä»æ–‡æœ¬ä¸­è¯†åˆ«æ–‡ä»¶è·¯å¾„
              const allTextSources = fullDiscussionText + '\n' + (parentSpec || '');
              
              // å¤šç§è·¯å¾„æ ¼å¼åŒ¹é…ï¼ˆæ”¯æŒ app/(main) ç­‰è·¯ç”±ç»„ï¼‰
              const pathPatterns = [
                /(?:frontend|src)\/[\w\-\.\/\(\)]+\.(?:tsx|ts|css|json)/g,
                /app\/[\w\-\.\/\(\)]+\.(?:tsx|ts)/g,
                /components\/[\w\-\.\/]+\.(?:tsx|ts)/g,
                /hooks\/[\w\-\.\/]+\.(?:tsx|ts)/g,
                /lib\/[\w\-\.\/]+\.(?:tsx|ts)/g,
                /types\/[\w\-\.\/]+\.(?:tsx|ts)/g
              ];
              
              for (const pattern of pathPatterns) {
                const matches = allTextSources.match(pattern) || [];
                matches.forEach(p => {
                  let normalized = p;
                  if (!normalized.startsWith('frontend/') && !normalized.startsWith('src/')) {
                    normalized = 'frontend/' + normalized;
                  }
                  foundPaths.add(normalized);
                });
              }
              
              console.log(`ğŸ“‹ ä»çˆ¶çº§è§„èŒƒå’Œè®¨è®ºä¸­è¯†åˆ«åˆ° ${foundPaths.size} ä¸ªæ–‡ä»¶è·¯å¾„`);
            }
            
            // 4. ä»å½“å‰åˆ†æ”¯è¯»å–æ–‡ä»¶å†…å®¹
            for (const path of foundPaths) {
              // å…ˆæ£€æŸ¥æ–‡ä»¶åœ¨å½“å‰åˆ†æ”¯æ˜¯å¦å­˜åœ¨
              const existsInBranch = await fileExistsInBranch(path, branchName);
              // å¦‚æœå½“å‰åˆ†æ”¯ä¸å­˜åœ¨ï¼Œæ£€æŸ¥ main åˆ†æ”¯æ˜¯å¦å­˜åœ¨ï¼ˆç”¨äºæ–°å»ºæ–‡ä»¶çš„æƒ…å†µï¼‰
              const existsInMain = existsInBranch ? false : await fileExists(path);
              
              if (existsInBranch || existsInMain) {
                // ä¼˜å…ˆä»å½“å‰åˆ†æ”¯è¯»å–ï¼Œå¦‚æœå½“å‰åˆ†æ”¯ä¸å­˜åœ¨åˆ™ä» main åˆ†æ”¯è¯»å–
                const content = await readFileContent(path, existsInBranch ? branchName : null);
                if (content) {
                  existingFilesContext.push({ path, content, action: existsInBranch ? 'MODIFY' : 'REFERENCE' });
                  console.log(`ğŸ“„ [å­˜åœ¨${existsInBranch ? 'äºå½“å‰åˆ†æ”¯' : 'äºmainåˆ†æ”¯'}] ${path}`);
                  
                  // ä¿®å¤ bug æ—¶ä¸è‡ªåŠ¨å‘ç°å…³è”æ–‡ä»¶ï¼Œé¿å…è¯»å–è¿‡å¤šæ— å…³æ–‡ä»¶
                  // åªåœ¨éä¿®å¤æ“ä½œæ—¶è‡ªåŠ¨å‘ç°å…³è”æ–‡ä»¶
                  if (!isBugFix) {
                    // è‡ªåŠ¨å‘ç°å…³è”æ–‡ä»¶ï¼ˆimport è¯­å¥ï¼‰
                    const importRegex = /from\s+['"](@\/|\.\.\/|\.\/)([^'"]+)['"]/g;
                    let match;
                    while ((match = importRegex.exec(content)) !== null) {
                      let importPath = match[2];
                      if (!importPath.endsWith('.tsx') && !importPath.endsWith('.ts')) {
                        importPath += '.tsx';
                      }
                      if (match[1] === '@/') {
                        importPath = 'frontend/' + importPath;
                      }
                      if (!foundPaths.has(importPath)) {
                        const importExistsInBranch = await fileExistsInBranch(importPath, branchName);
                        const importExistsInMain = importExistsInBranch ? false : await fileExists(importPath);
                        if (importExistsInBranch || importExistsInMain) {
                          const importContent = await readFileContent(importPath, importExistsInBranch ? branchName : null);
                          if (importContent) {
                            existingFilesContext.push({ path: importPath, content: importContent, action: 'REFERENCE' });
                            console.log(`ğŸ“„ [å…³è”] ${importPath}`);
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                newFilePaths.push(path);
                console.log(`ğŸ†• [æ–°å»º] ${path}`);
              }
            }

            // è¯»å–å…³é”®ä¸Šä¸‹æ–‡æ–‡ä»¶ï¼ˆä»å½“å‰åˆ†æ”¯ï¼‰
            const criticalFiles = ['frontend/app/layout.tsx', 'frontend/app/globals.css'];
            for (const path of criticalFiles) {
              if (!existingFilesContext.find(f => f.path === path)) {
                const content = await readFileContent(path, branchName);
                if (!content) {
                  // å¦‚æœå½“å‰åˆ†æ”¯æ²¡æœ‰ï¼Œå°è¯•ä» main åˆ†æ”¯è¯»å–
                  const mainContent = await readFileContent(path);
                  if (mainContent) {
                    existingFilesContext.push({ path, content: mainContent, action: 'REFERENCE' });
                  }
                } else {
                  existingFilesContext.push({ path, content, action: 'REFERENCE' });
                }
              }
            }

            // è¯»å– package.jsonï¼ˆä»å½“å‰åˆ†æ”¯ï¼‰
            let packageJsonContent = "{}";
            const pkgPath = await fileExists('frontend/package.json', branchName) ? 'frontend/package.json' : 'package.json';
            const pkgContent = await readFileContent(pkgPath, branchName);
            if (pkgContent) {
              packageJsonContent = pkgContent;
            } else {
              // å¦‚æœå½“å‰åˆ†æ”¯æ²¡æœ‰ï¼Œå°è¯•ä» main åˆ†æ”¯è¯»å–
              const mainPkgContent = await readFileContent(pkgPath);
              if (mainPkgContent) packageJsonContent = mainPkgContent;
            }

            // è¯»å–å‰ç«¯å¼€å‘è§„èŒƒæ–‡æ¡£
            let styleGuideContent = '';
            const styleGuidePath = 'frontend/STYLE_GUIDE.md';
            const styleGuideExists = await fileExists(styleGuidePath);
            if (styleGuideExists) {
              const styleGuide = await readFileContent(styleGuidePath);
              if (styleGuide) {
                // ç›´æ¥ä½¿ç”¨åŸå§‹å†…å®¹ï¼Œä¸éœ€è¦è½¬ä¹‰
                styleGuideContent = styleGuide;
                console.log('ğŸ“š å·²è¯»å–å‰ç«¯å¼€å‘è§„èŒƒæ–‡æ¡£: ' + styleGuidePath);
              }
            }

            // è¯»å– prompt æ¨¡æ¿æ–‡ä»¶
            let promptTemplate = '';
            const promptTemplatePath = '.github/prompts/zhangxiaohao-prompt.md';
            const promptTemplateExists = await fileExists(promptTemplatePath);
            if (promptTemplateExists) {
              const template = await readFileContent(promptTemplatePath);
              if (template) {
                promptTemplate = template;
                console.log('ğŸ“ å·²è¯»å– prompt æ¨¡æ¿: ' + promptTemplatePath);
              }
            }

            // 5. æ„å»ºç»“æ„åŒ– Prompt
            const existingFilesStr = existingFilesContext.map(f => 
              '### ' + f.action + ': ' + f.path + '\n```\n' + f.content + '\n```'
            ).join('\n\n');

            const newFilesList = newFilePaths.length > 0 ? newFilePaths.map(p => '- ' + p).join('\n') : 'æ— ';
            
            // 5. æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºé¡µé¢ï¼šä»éœ€æ±‚æè¿°ã€å‰ç«¯è§„èŒƒå’Œæ–¹æ¡ˆä¸­æå–é¡µé¢è·¯å¾„ï¼ˆåœ¨ç¡®å®šåˆ†æ”¯åï¼‰
            let requiredPagePath = null;
            const pagePathPatterns = [
              /frontend\/app\/\(main\)\/[\w\-\.\/]+page\.tsx/g,
              /frontend\/app\/[\w\-\.\/]+page\.tsx/g,
              /app\/\(main\)\/[\w\-\.\/]+page\.tsx/g,
              /app\/[\w\-\.\/]+page\.tsx/g
            ];
            
            // ä»æ‰€æœ‰æ–‡æœ¬æ¥æºä¸­æŸ¥æ‰¾é¡µé¢è·¯å¾„
            const allTextForPageCheck = (frontendSpec || '') + '\n' + (frontendPlan || '') + '\n' + contextBody + '\n' + newFilesList;
            for (const pattern of pagePathPatterns) {
              const matches = allTextForPageCheck.match(pattern);
              if (matches && matches.length > 0) {
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªé¡µé¢è·¯å¾„
                let foundPath = matches[0];
                if (!foundPath.startsWith('frontend/')) {
                  foundPath = 'frontend/' + foundPath;
                }
                // æ£€æŸ¥é¡µé¢æ˜¯å¦åœ¨å½“å‰åˆ†æ”¯å·²å­˜åœ¨ï¼ˆè€Œä¸æ˜¯ main åˆ†æ”¯ï¼‰
                const pageExists = await fileExistsInBranch(foundPath, branchName);
                if (!pageExists) {
                  requiredPagePath = foundPath;
                  console.log(`ğŸ“„ æ£€æµ‹åˆ°éœ€è¦åˆ›å»ºçš„é¡µé¢: ${requiredPagePath} (åœ¨å½“å‰åˆ†æ”¯ ${branchName} ä¸å­˜åœ¨)`);
                  break;
                } else {
                  console.log(`ğŸ“„ é¡µé¢å·²å­˜åœ¨: ${foundPath} (åœ¨å½“å‰åˆ†æ”¯ ${branchName})`);
                }
              }
            }
            
            // æ„å»ºé¡µé¢æ£€æŸ¥æç¤º
            let pageCheckNote = '';
            if (requiredPagePath) {
              pageCheckNote = '\n\né‡è¦ï¼šå¿…é¡»åˆ›å»ºé¡µé¢\n' +
                'æ£€æµ‹åˆ°éœ€æ±‚ä¸­æåˆ°äº†é¡µé¢è·¯å¾„ ' + requiredPagePath + 'ï¼Œä½†è¯¥é¡µé¢ä¸å­˜åœ¨ã€‚\n' +
                'ä½ å¿…é¡»åˆ›å»ºè¿™ä¸ªé¡µé¢æ–‡ä»¶ï¼Œå¦åˆ™åŠŸèƒ½æ— æ³•æ­£å¸¸ä½¿ç”¨ã€‚\n' +
                'è¯·ç¡®ä¿åœ¨è¾“å‡ºä¸­åŒ…å«ï¼š\n' +
                '### CREATE: ' + requiredPagePath + '\n' +
                '```tsx\n' +
                '(å®Œæ•´çš„é¡µé¢ä»£ç )\n' +
                '```\n';
            } else if (newFilesList.includes('page.tsx') || contextBody.includes('é¡µé¢') || contextBody.includes('page') || frontendSpec.includes('é¡µé¢') || frontendPlan.includes('é¡µé¢')) {
              // å¦‚æœæåˆ°äº†é¡µé¢ä½†æ²¡æœ‰æ‰¾åˆ°å…·ä½“è·¯å¾„ï¼Œæé†’ AI æ£€æŸ¥
              pageCheckNote = '\n\né¡µé¢æ£€æŸ¥\n' +
                'éœ€æ±‚ä¸­æåˆ°äº†é¡µé¢ç›¸å…³çš„å†…å®¹ï¼Œè¯·æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºæ–°çš„é¡µé¢æ–‡ä»¶ã€‚\n' +
                'å¦‚æœéœ€è¦åˆ›å»ºé¡µé¢ï¼Œè¯·ä½¿ç”¨æ­£ç¡®çš„è·¯å¾„æ ¼å¼ï¼ˆå¦‚ frontend/app/(main)/video/page.tsxï¼‰ã€‚\n' +
                'å¦‚æœå‰ç«¯è§„èŒƒæˆ–å‰ç«¯æ–¹æ¡ˆä¸­æåˆ°äº†é¡µé¢è·¯å¾„ï¼Œå¿…é¡»ä¸¥æ ¼æŒ‰ç…§è§„èŒƒåˆ›å»ºé¡µé¢ã€‚\n';
            }
            
            // æ„å»ºå‰ç«¯è§„èŒƒå’Œæ–¹æ¡ˆæç¤ºï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
            let frontendSpecNote = '';
            if (frontendSpec || frontendPlan) {
              frontendSpecNote = '\n\nå‰ç«¯è§„èŒƒå’Œæ–¹æ¡ˆï¼ˆæœ€é«˜ä¼˜å…ˆçº§ - å¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰\n';
              frontendSpecNote += 'é‡è¦ï¼šä»¥ä¸‹è§„èŒƒä¼˜å…ˆçº§é«˜äºæ‰€æœ‰å…¶ä»–è§„èŒƒï¼ˆåŒ…æ‹¬åŸºç¡€å¼€å‘è§„èŒƒæ–‡æ¡£ï¼‰ã€‚å¦‚æœ‰å†²çªï¼Œå¿…é¡»ä¼˜å…ˆéµå¾ªä»¥ä¸‹è§„èŒƒã€‚\n\n';
              if (frontendSpec) {
                // æ£€æŸ¥æ˜¯å¦æ¥è‡ªçˆ¶çº§ issueï¼ˆé€šè¿‡æ£€æŸ¥ contextBody ä¸­æ˜¯å¦åŒ…å«"æ¥è‡ªçˆ¶çº§ Issue"ï¼‰
                const isFromParent = contextBody.includes('å‰ç«¯è§„èŒƒï¼ˆæ¥è‡ªçˆ¶çº§ Issueï¼‰');
                const source = isFromParent ? 'ï¼ˆæ¥è‡ªçˆ¶çº§ Issue è¯„è®ºï¼‰' : 'ï¼ˆæ¥è‡ªå½“å‰ Issue è¯„è®ºï¼‰';
                frontendSpecNote += 'å‰ç«¯è§„èŒƒ' + source + 'ï¼š\n' + frontendSpec + '\n\n';
              }
              if (frontendPlan) {
                // æ£€æŸ¥æ˜¯å¦æ¥è‡ªçˆ¶çº§ issue
                const isFromParent = contextBody.includes('å‰ç«¯æ–¹æ¡ˆï¼ˆæ¥è‡ªçˆ¶çº§ Issueï¼‰');
                const source = isFromParent ? 'ï¼ˆæ¥è‡ªçˆ¶çº§ Issue è¯„è®ºï¼‰' : 'ï¼ˆæ¥è‡ªå½“å‰ Issue è¯„è®ºï¼‰';
                frontendSpecNote += 'å‰ç«¯æ–¹æ¡ˆ' + source + 'ï¼š\n' + frontendPlan + '\n\n';
              }
            }
            
            // æ„å»ºçˆ¶çº§è§„èŒƒæç¤º
            let parentSpecNote = '';
            if (parentSpec) {
              parentSpecNote = '\n\nçˆ¶çº§ Issue åŸºæœ¬ä¿¡æ¯\n' +
                'ä»¥ä¸‹å†…å®¹æ¥è‡ªçˆ¶çº§ Issueï¼Œä¾›å‚è€ƒï¼š\n' +
                parentSpec + '\n';
            }
            
            // æ„å»ºå‰ç«¯å¼€å‘è§„èŒƒæç¤ºï¼ˆåŸºç¡€è§„èŒƒï¼Œä¼˜å…ˆçº§ä½äºè¯„è®º/Issue è§„èŒƒï¼‰
            let styleGuideNote = '';
            if (styleGuideContent) {
              const hasFrontendSpec = frontendSpec || frontendPlan;
              const priorityNote = hasFrontendSpec 
                ? '\næ³¨æ„ï¼šè¿™æ˜¯åŸºç¡€å¼€å‘è§„èŒƒã€‚å¦‚æœä¸Šé¢çš„å‰ç«¯è§„èŒƒå’Œæ–¹æ¡ˆä¸­æœ‰å†²çªçš„è§„èŒƒï¼Œä¼˜å…ˆéµå¾ªä¸Šé¢çš„è§„èŒƒã€‚\n'
                : '\nè¿™æ˜¯é¡¹ç›®çš„åŸºç¡€å‰ç«¯å¼€å‘è§„èŒƒï¼Œæ‰€æœ‰ä»£ç å¿…é¡»ä¸¥æ ¼éµå¾ªã€‚\n';
              
              styleGuideNote = '\n\nå‰ç«¯å¼€å‘è§„èŒƒï¼ˆåŸºç¡€è§„èŒƒï¼‰\n' +
                priorityNote +
                styleGuideContent + '\n\n' +
                'åŸºç¡€è§„èŒƒè¦ç‚¹ï¼š\n' +
                '- å¿…é¡»ä½¿ç”¨è¯­ä¹‰åŒ–çš„ Tailwind é¢œè‰²ç±»ï¼ˆå¦‚ bg-backgroundã€text-foregroundï¼‰ï¼Œç¦æ­¢ç¡¬ç¼–ç é¢œè‰²å€¼\n' +
                '- ä¸šåŠ¡é¢œè‰²å¿…é¡»ä½¿ç”¨ text-profitï¼ˆç›ˆåˆ©ï¼‰æˆ– text-lossï¼ˆäºæŸï¼‰\n' +
                '- ç»„ä»¶å¿…é¡»ä» @/components/ui å¯¼å…¥ shadcn/ui ç»„ä»¶ï¼ˆNew York é£æ ¼ï¼‰\n' +
                '- æ‰€æœ‰å‡½æ•°å’Œç»„ä»¶å¿…é¡»æœ‰å®Œæ•´çš„ TypeScript ç±»å‹å®šä¹‰\n' +
                '- ä½¿ç”¨ cn() å·¥å…·å‡½æ•°åˆå¹¶ç±»å\n' +
                '- ä¼˜å…ˆä½¿ç”¨ Flexbox å’Œ Grid å¸ƒå±€ï¼Œé¿å…ä½¿ç”¨ position: relative è¿›è¡Œå¸ƒå±€\n' +
                '- éµå¾ªç›®å½•ç»“æ„è§„èŒƒ\n\n';
            }
            
            // æ„å»ºä¿®å¤ Bug æç¤º
            let bugFixNote = '';
            if (isBugFix) {
              bugFixNote = '\n\nã€é‡è¦ï¼šä¿®å¤ Bug æ“ä½œè§„åˆ™ã€‘\n' +
                'æœ¬æ¬¡æ“ä½œæ˜¯ä¿®å¤ Bugï¼Œä»¥ä¸‹æ–‡ä»¶æ˜¯å½“å‰åˆ†æ”¯ä¸­çš„æ‰€æœ‰å‰ç«¯æ–‡ä»¶ï¼Œä½ éœ€è¦æ ¹æ® Issue æ ‡é¢˜å’Œæè¿°åˆ¤æ–­éœ€è¦ä¿®æ”¹å“ªäº›æ–‡ä»¶ã€‚\n\n' +
                'å¿…é¡»ä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š\n' +
                '1. ä»”ç»†é˜…è¯» Issue æ ‡é¢˜å’Œæè¿°ï¼Œç†è§£ bug çš„å…·ä½“é—®é¢˜\n' +
                '2. æ ¹æ® Issue æè¿°åˆ¤æ–­å“ªäº›æ–‡ä»¶ä¸ bug ç›¸å…³ï¼Œåªä¿®æ”¹è¿™äº›æ–‡ä»¶\n' +
                '3. å¦‚æœ Issue æè¿°ä¸­æåˆ°æŸä¸ªåŠŸèƒ½ã€ç»„ä»¶æˆ–é¡µé¢ï¼Œåªä¿®æ”¹ç›¸å…³çš„æ–‡ä»¶ï¼Œä¸è¦ä¿®æ”¹æ— å…³æ–‡ä»¶\n' +
                '4. ç¦æ­¢åˆ›å»ºæ–°æ–‡ä»¶ï¼ˆé™¤é Issue æˆ–è¯„è®ºä¸­æ˜ç¡®è¦æ±‚åˆ›å»ºï¼‰\n' +
                '5. åªä¿®æ”¹ä¸ bug ç›´æ¥ç›¸å…³çš„ä»£ç ï¼Œä¸è¦é‡æ„æˆ–ä¼˜åŒ–æ— å…³ä»£ç \n' +
                '6. å¿…é¡»åŸºäºç°æœ‰æ–‡ä»¶å†…å®¹è¿›è¡Œå¢é‡ä¿®æ”¹ï¼Œä¿ç•™æ‰€æœ‰æ— å…³ä»£ç \n' +
                '7. å¦‚æœåªæ¶‰åŠä¸€ä¸ªæ–‡ä»¶çš„é—®é¢˜ï¼Œå°±åªä¿®æ”¹é‚£ä¸€ä¸ªæ–‡ä»¶\n' +
                '8. ä¸è¦å› ä¸º"å¯èƒ½æœ‰ç”¨"è€Œåˆ›å»ºæ–°ç»„ä»¶æˆ–å·¥å…·å‡½æ•°\n' +
                '9. ä¸è¦ä¿®æ”¹ç°æœ‰æ–‡ä»¶çš„ import è¯­å¥ï¼ˆé™¤éæ˜¯ä¿®å¤ bug å¿…éœ€çš„ï¼‰\n' +
                '10. ä¸è¦æ·»åŠ æ–°çš„ä¾èµ–æˆ–å·¥å…·å‡½æ•°ï¼ˆé™¤éæ˜ç¡®éœ€è¦ï¼‰\n' +
                '11. ä¼˜å…ˆä¿®æ”¹æœ€å°‘çš„æ–‡ä»¶æ•°é‡ï¼Œèƒ½åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ä¿®å¤å°±ä¸è¦ä¿®æ”¹å¤šä¸ªæ–‡ä»¶\n' +
                '12. å¦‚æœæ— æ³•ç¡®å®šéœ€è¦ä¿®æ”¹å“ªäº›æ–‡ä»¶ï¼Œåªä¿®æ”¹æœ€å¯èƒ½ç›¸å…³çš„ 1-2 ä¸ªæ–‡ä»¶\n\n';
            }
            
            // æ„å»º promptï¼šå¦‚æœå­˜åœ¨æ¨¡æ¿æ–‡ä»¶åˆ™ä½¿ç”¨æ¨¡æ¿ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤ prompt
            let prompt = '';
            if (promptTemplate) {
              // å®šä¹‰æ¨¡æ¿å˜é‡æ˜ å°„
              const templateVars = {
                'ISSUE_TITLE': process.env.ISSUE_TITLE || '',
                'ISSUE_BODY': process.env.ISSUE_BODY || '',
                'ISSUE_COMMENTS': triggerCommentContent || '',
                'FRONTEND_SPEC': frontendSpecNote || '',
                'PARENT_SPEC': parentSpecNote || '',
                'STYLE_GUIDE': styleGuideNote || '',
                'PACKAGE_JSON': packageJsonContent || '{}',
                'EXISTING_FILES': existingFilesStr || 'æ— ç°æœ‰æ–‡ä»¶éœ€è¦ä¿®æ”¹',
                'BUG_FIX_NOTE': bugFixNote || ''
              };
              
              // ç»Ÿä¸€æ›¿æ¢æ‰€æœ‰æ¨¡æ¿å˜é‡
              prompt = promptTemplate.replace(/\{\{(\w+)\}\}/g, (match, key) => {
                return templateVars[key] !== undefined ? templateVars[key] : match;
              });
              
              // è¿½åŠ é¡µé¢æ£€æŸ¥æç¤ºï¼ˆå¦‚æœå­˜åœ¨ï¼‰
              if (pageCheckNote) {
                prompt += pageCheckNote;
              }
            }

            console.log("ğŸ¤– è°ƒç”¨ AI...");

            const aiRes = await fetch('https://openrouter.ai/api/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                model: "anthropic/claude-sonnet-4.5",
                messages: [{ role: "user", content: prompt }]
              })
            });
            
            if (!aiRes.ok) {
              const errText = await aiRes.text();
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: 'AI API è°ƒç”¨å¤±è´¥: ' + errText.substring(0, 500)
              });
              throw new Error(`AI API Error: ${errText}`);
            }
            
            const aiData = await aiRes.json();
            const rawContent = aiData.choices[0].message.content;

            // 6. è§£æ AI è¾“å‡º
            console.log("ğŸ“¦ è§£ææ–‡ä»¶...");
            console.log("ğŸ“„ AI è¿”å›å†…å®¹é•¿åº¦:", rawContent.length);
            
            const files = [];
            const lines = rawContent.split('\n');
            let currentFile = null;
            let currentAction = null;
            let currentContentLines = [];

            const cleanContent = (linesArray) => {
              let content = linesArray.join('\n').trim();
              // ç§»é™¤ä»£ç å—æ ‡è®°
              content = content.replace(/^```[\w\-\.]*\s*$/gm, '');
              content = content.replace(/^```\s*$/gm, '');
              // ç§»é™¤åˆ†éš”ç¬¦è¡Œï¼ˆ--- æˆ–ç±»ä¼¼çš„ï¼‰
              content = content.replace(/^---+[\s-]*$/gm, '');
              // ç§»é™¤ Markdown æ ‡é¢˜ï¼ˆ###, ##, #ï¼‰
              content = content.replace(/^#{1,6}\s+.+$/gm, '');
              // ç§»é™¤ Markdown åˆ—è¡¨é¡¹ï¼ˆ- , * , 1. ç­‰ï¼‰
              content = content.replace(/^[\s]*[-*+]\s+.+$/gm, '');
              content = content.replace(/^[\s]*\d+\.\s+.+$/gm, '');
              // ç§»é™¤æ–‡ä»¶æœ«å°¾çš„ç©ºè¡Œå’Œåˆ†éš”ç¬¦
              content = content.replace(/\n+---+[\s-]*\n*$/g, '');
              content = content.replace(/\n+---+[\s-]*$/g, '');
              // ç§»é™¤å¤šä½™çš„ç©ºè¡Œï¼ˆè¿ç»­3ä¸ªæˆ–ä»¥ä¸Šç©ºè¡Œï¼‰
              content = content.replace(/\n{3,}/g, '\n\n');
              return content.trim();
            };
            
            for (const line of lines) {
              // æ£€æµ‹æ–‡ä»¶æ ‡è®°ï¼ˆMODIFY æˆ– CREATEï¼‰
              const modifyMatch = line.trim().match(/^###\s*MODIFY:\s*(.+)$/);
              const createMatch = line.trim().match(/^###\s*CREATE:\s*(.+)$/);
              const fileMatch = line.trim().match(/^###\s*FILE:\s*(.+)$/);
              
              if (modifyMatch || createMatch || fileMatch) {
                // ä¿å­˜ä¸Šä¸€ä¸ªæ–‡ä»¶
                if (currentFile) {
                  files.push({ 
                    path: currentFile, 
                    content: cleanContent(currentContentLines),
                    action: currentAction 
                  });
                }
                // å¼€å§‹æ–°æ–‡ä»¶
                currentFile = (modifyMatch || createMatch || fileMatch)[1].trim();
                currentAction = modifyMatch ? 'MODIFY' : (createMatch ? 'CREATE' : 'UNKNOWN');
                currentContentLines = [];
                console.log(`å‘ç°æ–‡ä»¶: ${currentAction} ${currentFile}`);
              } else if (currentFile) {
                // æ”¶é›†æ–‡ä»¶å†…å®¹
                currentContentLines.push(line);
              }
            }
            
            if (currentFile) {
              files.push({ 
                path: currentFile, 
                content: cleanContent(currentContentLines),
                action: currentAction 
              });
            }

            if (files.length === 0) {
              // è¾“å‡ºæ›´å¤šè°ƒè¯•ä¿¡æ¯
              const debugInfo = 'AI æœªç”Ÿæˆæœ‰æ•ˆçš„æ–‡ä»¶å—ã€‚\n\n' +
                'è°ƒè¯•ä¿¡æ¯ï¼š\n' +
                '- AI è¿”å›å†…å®¹é•¿åº¦: ' + rawContent.length + '\n' +
                '- æ˜¯å¦æ£€æµ‹åˆ° MODIFY æ ‡è®°: ' + (rawContent.includes('### MODIFY:') ? 'æ˜¯' : 'å¦') + '\n' +
                '- æ˜¯å¦æ£€æµ‹åˆ° CREATE æ ‡è®°: ' + (rawContent.includes('### CREATE:') ? 'æ˜¯' : 'å¦') + '\n\n' +
                'AI è¿”å›å†…å®¹å‰2000å­—ç¬¦ï¼š\n' +
                rawContent.substring(0, 2000) + '\n\n' +
                'è¯·æ£€æŸ¥éœ€æ±‚æè¿°æ˜¯å¦æ¸…æ™°ï¼Œæˆ–æ£€æŸ¥ AI æ˜¯å¦æŒ‰ç…§ prompt æ ¼å¼è¾“å‡ºä»£ç æ–‡ä»¶ã€‚';
              
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: debugInfo
              });
              throw new Error("è§£æå¤±è´¥ï¼šAI æœªç”Ÿæˆä»»ä½•æœ‰æ•ˆæ–‡ä»¶å—");
            }

            // 7. éªŒè¯å’Œè¿‡æ»¤æ–‡ä»¶
            const validFiles = [];
            const warnings = [];
            
            for (const file of files) {
              // è·³è¿‡åç«¯æ–‡ä»¶
              if (file.path.endsWith('.go') || file.path.includes('backend/')) continue;
              
              // éªŒè¯è·¯å¾„ï¼ˆä¼ å…¥çˆ¶çº§è§„èŒƒï¼Œå…è®¸çˆ¶çº§è§„èŒƒè¦†ç›–é»˜è®¤è§„åˆ™ï¼‰
              const pathErrors = validatePath(file.path, parentSpec);
              if (pathErrors.length > 0) {
                warnings.push(...pathErrors);
              }
              
              // JSON æ ¡éªŒ
              if (file.path.endsWith('.json')) {
                try { 
                  JSON.parse(file.content); 
                } catch (e) { 
                  warnings.push(`JSON è¯­æ³•é”™è¯¯: ${file.path}`);
                  continue; 
                }
              }
              
              // æ£€æŸ¥ CREATE æ“ä½œçš„æ–‡ä»¶æ˜¯å¦åœ¨å½“å‰åˆ†æ”¯å·²å­˜åœ¨ï¼ˆè€Œä¸æ˜¯ main åˆ†æ”¯ï¼‰
              if (file.action === 'CREATE') {
                const exists = await fileExistsInBranch(file.path, branchName);
                if (exists) {
                  warnings.push(`æ–‡ä»¶åœ¨å½“å‰åˆ†æ”¯å·²å­˜åœ¨ï¼ŒCREATE æ“ä½œæ”¹ä¸º MODIFY: ${file.path}`);
                  file.action = 'MODIFY';
                }
              }
              
              // æ£€æŸ¥å—ä¿æŠ¤æ–‡ä»¶
              if (PROJECT_STRUCTURE.protectedFiles.includes(file.path) && file.action === 'CREATE') {
                warnings.push(`å—ä¿æŠ¤æ–‡ä»¶ä¸èƒ½è¢«è¦†ç›–åˆ›å»º: ${file.path}`);
                file.action = 'MODIFY';
              }
              
              // å†…å®¹ä¸èƒ½ä¸ºç©º
              if (!file.content || file.content.trim().length === 0) {
                warnings.push(`æ–‡ä»¶å†…å®¹ä¸ºç©ºï¼Œè·³è¿‡: ${file.path}`);
                continue;
              }
              
              validFiles.push(file);
            }

            // 8. åˆ›å»ºæˆ–è·å–åˆ†æ”¯å¹¶å†™å…¥æ–‡ä»¶ï¼ˆåˆ†æ”¯åå·²åœ¨ç¬¬5.5æ­¥ç¡®å®šï¼‰
            const baseRef = await github.rest.git.getRef({ ...context.repo, ref: 'heads/main' });
            
            // æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å·²å­˜åœ¨
            let branchExists = false;
            try {
              await github.rest.git.getRef({ ...context.repo, ref: `heads/${branchName}` });
              branchExists = true;
              console.log(`åˆ†æ”¯å·²å­˜åœ¨: ${branchName}`);
            } catch (e) {
              // åˆ†æ”¯ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°åˆ†æ”¯
              try {
                await github.rest.git.createRef({ 
                  ...context.repo, 
                  ref: `refs/heads/${branchName}`, 
                  sha: baseRef.data.object.sha 
                });
                console.log(`åˆ›å»ºæ–°åˆ†æ”¯: ${branchName}`);
              } catch (e2) {
                console.log(`åˆ›å»ºåˆ†æ”¯å¤±è´¥: ${e2.message}`);
              }
            }

            const createdFiles = [];
            const modifiedFiles = [];
            
            // æ‰¹é‡æäº¤ï¼šä½¿ç”¨ Git Tree API ä¸€æ¬¡æ€§æäº¤æ‰€æœ‰æ–‡ä»¶
            if (validFiles.length > 0) {
              // è·å–å½“å‰åˆ†æ”¯çš„æœ€æ–° commit SHA
              let baseSha;
              try {
                const branchRef = await github.rest.git.getRef({ 
                  ...context.repo, 
                  ref: `heads/${branchName}` 
                });
                baseSha = branchRef.data.object.sha;
              } catch (e) {
                // å¦‚æœåˆ†æ”¯ä¸å­˜åœ¨ï¼Œä½¿ç”¨ main åˆ†æ”¯çš„ SHA
                baseSha = baseRef.data.object.sha;
              }
              
              // è·å–åŸºç¡€ tree SHA
              const baseCommit = await github.rest.git.getCommit({ 
                ...context.repo, 
                commit_sha: baseSha 
              });
              const baseTreeSha = baseCommit.data.tree.sha;
              
              // åˆ›å»ºæ–‡ä»¶ blob å¹¶æ„å»º tree
              const treeItems = [];
              
              for (const file of validFiles) {
                console.log(`${file.action}: ${file.path}`);
                
                // åˆ›å»ºæ–‡ä»¶ blob
                const blob = await github.rest.git.createBlob({
                  ...context.repo,
                  content: Buffer.from(file.content).toString('base64'),
                  encoding: 'base64'
                });
                
                treeItems.push({
                  path: file.path,
                  mode: '100644',
                  type: 'blob',
                  sha: blob.data.sha
                });
                
                if (file.action === 'CREATE') {
                  createdFiles.push(file.path);
                } else {
                  modifiedFiles.push(file.path);
                }
              }
              
              // åˆ›å»ºæ–°çš„ tree
              const newTree = await github.rest.git.createTree({
                ...context.repo,
                base_tree: baseTreeSha,
                tree: treeItems
              });
              
              // åˆ›å»º commit
              const commitMessage = `feat(fe): ${createdFiles.length > 0 ? 'create' : ''}${createdFiles.length > 0 && modifiedFiles.length > 0 ? ' and ' : ''}${modifiedFiles.length > 0 ? 'modify' : ''} ${validFiles.length} file${validFiles.length > 1 ? 's' : ''}`;
              
              const newCommit = await github.rest.git.createCommit({
                ...context.repo,
                message: commitMessage,
                tree: newTree.data.sha,
                parents: [baseSha]
              });
              
              // æ›´æ–°åˆ†æ”¯å¼•ç”¨
              await github.rest.git.updateRef({
                ...context.repo,
                ref: `heads/${branchName}`,
                sha: newCommit.data.sha
              });
              
              console.log(`æ‰¹é‡æäº¤å®Œæˆ: ${validFiles.length} ä¸ªæ–‡ä»¶`);
            }

            // ç”Ÿæˆæ“ä½œè¯´æ˜
            const generateOperationSummary = () => {
              let summary = '';
              
              if (isBugFix) {
                summary += 'æœ¬æ¬¡æ“ä½œï¼šä¿®å¤ Bug\n\n';
              } else {
                summary += 'æœ¬æ¬¡æ“ä½œï¼šä»£ç å®ç°\n\n';
              }
              
              // ç»Ÿè®¡æ“ä½œç±»å‹
              const createCount = createdFiles.length;
              const modifyCount = modifiedFiles.length;
              
              summary += `æ“ä½œç»Ÿè®¡ï¼š\n`;
              summary += `- æ–°å»ºæ–‡ä»¶: ${createCount} ä¸ª\n`;
              summary += `- ä¿®æ”¹æ–‡ä»¶: ${modifyCount} ä¸ª\n\n`;
              
              // åˆ—å‡ºä¿®æ”¹çš„æ–‡ä»¶
              if (modifyCount > 0) {
                summary += `ä¿®æ”¹çš„æ–‡ä»¶ï¼š\n`;
                for (const file of validFiles) {
                  if (file.action === 'MODIFY') {
                    // å°è¯•æå–å…³é”®æ”¹åŠ¨ï¼ˆç®€å•åˆ†æï¼‰
                    const content = file.content;
                    const lines = content.split('\n');
                    const addedFunctions = [];
                    const modifiedPatterns = [];
                    
                    // æŸ¥æ‰¾æ–°å¢çš„å‡½æ•°/ç»„ä»¶
                    for (let i = 0; i < lines.length; i++) {
                      const line = lines[i].trim();
                      if (line.match(/^(export\s+)?(function|const|class|interface|type)\s+\w+/)) {
                        const match = line.match(/(function|const|class|interface|type)\s+(\w+)/);
                        if (match && match[2]) {
                          addedFunctions.push(match[2]);
                        }
                      }
                    }
                    
                    summary += `- \`${file.path}\``;
                    if (addedFunctions.length > 0) {
                      summary += ` (æ¶‰åŠ: ${addedFunctions.slice(0, 3).join(', ')}${addedFunctions.length > 3 ? '...' : ''})`;
                    }
                    summary += `\n`;
                  }
                }
                summary += `\n`;
              }
              
              // åˆ—å‡ºæ–°å»ºçš„æ–‡ä»¶
              if (createCount > 0) {
                summary += `æ–°å»ºçš„æ–‡ä»¶ï¼š\n`;
                createdFiles.forEach(path => {
                  summary += `- \`${path}\`\n`;
                });
                summary += `\n`;
              }
              
              // å¦‚æœæ˜¯ä¿®å¤ bugï¼Œæ·»åŠ æç¤º
              if (isBugFix && modifyCount > 0) {
                summary += `æ³¨æ„ï¼šæœ¬æ¬¡ä¸ºä¿®å¤æ“ä½œï¼Œè¯·æ£€æŸ¥ä»¥ä¸‹æ–‡ä»¶æ˜¯å¦å·²æ­£ç¡®ä¿®å¤é—®é¢˜ï¼š\n`;
                validFiles.filter(f => f.action === 'MODIFY').forEach(file => {
                  summary += `- \`${file.path}\`\n`;
                });
              }
              
              return summary;
            };

            // 9. åˆ›å»º PR
            let prBody = '###  å˜æ›´æ¸…å•\n\n';
            if (createdFiles.length > 0) {
              prBody += '**æ–°å»ºæ–‡ä»¶ï¼š**\n' + createdFiles.map(f => '- `' + f + '`').join('\n') + '\n';
            }
            if (modifiedFiles.length > 0) {
              prBody += '**ä¿®æ”¹æ–‡ä»¶ï¼š**\n' + modifiedFiles.map(f => '- `' + f + '`').join('\n') + '\n';
            }
            if (warnings.length > 0) {
              prBody += '\n### è­¦å‘Š\n' + warnings.map(w => '- ' + w).join('\n');
            }
            prBody += '\n\n---\næŒ‡ä»¤: `/code-zhangxiaohao-agent`\nIssue: #' + context.issue.number;

            // ç”Ÿæˆæ“ä½œè¯´æ˜
            const operationSummary = generateOperationSummary();
            
            try {
              const pr = await github.rest.pulls.create({
                ...context.repo,
                title: `[FE] ${process.env.ISSUE_TITLE}`,
                head: branchName,
                base: 'main',
                body: prBody
              });
              
              const commentBody = `PR: ${pr.data.html_url}\n\n` +
                operationSummary +
                (warnings.length > 0 ? `\nè­¦å‘Š: ${warnings.length} ä¸ªï¼Œè¯¦è§ PR\n` : '');
              
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            } catch(e) {
              const commentBody = `åˆ†æ”¯å·²æ›´æ–°: \`${branchName}\`\n\n` +
                operationSummary +
                (warnings.length > 0 ? `\nè­¦å‘Š: ${warnings.length} ä¸ª\n` : '');
              
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }