name: Update PRD Status

on:
  # å½“ issue å…³é—­æ—¶è§¦å‘
  issues:
    types: [closed, reopened]
  # æ”¯æŒæ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      force_update:
        description: 'å¼ºåˆ¶æ›´æ–°æ‰€æœ‰å­ issue çŠ¶æ€'
        required: false
        default: 'true'
        type: boolean

jobs:
  update-prd:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update PRD issue status
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // ä»Žé…ç½®æ–‡ä»¶è¯»å– PRD é…ç½®
            let config;
            try {
              const configPath = '.github/config/workflow-config.json';
              const configContent = fs.readFileSync(configPath, 'utf8');
              config = JSON.parse(configContent);
            } catch (error) {
              core.setFailed(`æ— æ³•è¯»å–é…ç½®æ–‡ä»¶: ${error.message}`);
              return;
            }

            const PRD_ISSUE = config.prd.issue_number;

            // ä»Žé…ç½®æ–‡ä»¶è¯»å–å­ issue é…ç½®
            const SUB_ISSUES = config.prd.sub_issues.map(sub => ({
              number: sub.number,
              priority: sub.priority,
              name: sub.name,
              hasFrontend: sub.frontend,
              hasBackend: sub.backend
            }));

            console.log(`ðŸ“‹ PRD Issue: #${PRD_ISSUE}`);
            console.log(`ðŸ“Ž å­ Issues: ${SUB_ISSUES.map(s => `#${s.number}`).join(', ')}`);

            // èŽ·å–æ‰€æœ‰å­ issue çš„çŠ¶æ€
            const issueStatuses = await Promise.all(
              SUB_ISSUES.map(async (sub) => {
                try {
                  const { data: issue } = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: sub.number,
                  });

                  const labels = issue.labels.map(l => typeof l === 'string' ? l : l.name);
                  const isClosed = issue.state === 'closed';
                  const hasAiCompleted = labels.includes('ai:completed');
                  const hasDeployed = labels.includes('âœ… deployed');

                  return {
                    ...sub,
                    state: issue.state,
                    labels,
                    isClosed,
                    hasAiCompleted,
                    hasDeployed,
                  };
                } catch (error) {
                  console.log(`æ— æ³•èŽ·å– issue #${sub.number}: ${error.message}`);
                  return { ...sub, state: 'unknown', labels: [] };
                }
              })
            );

            // ç”ŸæˆçŠ¶æ€ emoji
            function getStatusEmoji(issue) {
              if (issue.isClosed || issue.hasDeployed) return 'âœ… å·²å®Œæˆ';
              if (issue.hasAiCompleted) return 'ðŸ”¶ å¾…éƒ¨ç½²';
              return 'ðŸ”¶ å¼€å‘ä¸­';
            }

            function getFrontendEmoji(issue) {
              if (!issue.hasFrontend) return 'âŒ';
              if (issue.isClosed || issue.hasDeployed) return 'âœ…';
              if (issue.labels.includes('agent:frontend') || issue.hasAiCompleted) return 'âœ…';
              return 'âš ï¸';
            }

            function getBackendEmoji(issue) {
              if (!issue.hasBackend) return 'âŒ';
              if (issue.isClosed || issue.hasDeployed) return 'âœ…';
              return 'âœ…';
            }

            // èŽ·å–å½“å‰ PRD issue å†…å®¹
            const { data: prdIssue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: PRD_ISSUE,
            });

            let body = prdIssue.body;

            // æž„å»ºæ–°çš„çŠ¶æ€è¡¨æ ¼
            const tableRows = issueStatuses.map(issue => {
              const fe = getFrontendEmoji(issue);
              const be = getBackendEmoji(issue);
              const status = getStatusEmoji(issue);
              return `| **${issue.priority}** | #${issue.number} | ${issue.name} | ${fe} | ${be} | ${status} |`;
            }).join('\n');

            const newTable = `| Priority | Issue | åŠŸèƒ½æ¨¡å— | å‰ç«¯ | åŽç«¯ | çŠ¶æ€ |
            |----------|-------|---------|------|------|------|
            ${tableRows}`;

            // æ›¿æ¢è¡¨æ ¼ (ä½¿ç”¨ç®€å•çš„å­—ç¬¦ä¸²æ›¿æ¢)
            const tableStart = '| Priority | Issue | åŠŸèƒ½æ¨¡å— | å‰ç«¯ | åŽç«¯ | çŠ¶æ€ |';
            const tableStartIndex = body.indexOf(tableStart);
            if (tableStartIndex !== -1) {
              // æ‰¾åˆ°è¡¨æ ¼ç»“æŸä½ç½® (ä¸‹ä¸€ä¸ª --- æˆ– ##)
              const afterTableStart = body.substring(tableStartIndex);
              const nextSectionMatch = afterTableStart.match(/\n\n---|\n\n##/);
              if (nextSectionMatch) {
                const tableEndIndex = tableStartIndex + nextSectionMatch.index;
                body = body.substring(0, tableStartIndex) + newTable.split('\n').map(l => l.trim()).join('\n') + body.substring(tableEndIndex);
              }
            }

            // æ›´æ–°å­ issue åˆ—è¡¨
            const checklistItems = issueStatuses.map(issue => {
              const checked = issue.isClosed || issue.hasDeployed ? '[x]' : '[ ]';
              const status = issue.isClosed ? 'âœ… å·²å®Œæˆ' : (issue.hasAiCompleted ? 'ðŸ”¶ å¾…éƒ¨ç½²' : 'ðŸ”¶ å¼€å‘ä¸­');
              const issueType = issue.hasFrontend && issue.hasBackend ? '[BE+FE]' : (issue.hasFrontend ? '[FE]' : '[BE]');
              return `- ${checked} #${issue.number} **${issue.priority}**: ${issueType} ${issue.name} - ${status}`;
            }).join('\n');

            const checklistHeader = '## ðŸ“Ž å­ Issue åˆ—è¡¨';
            const checklistIndex = body.indexOf(checklistHeader);
            if (checklistIndex !== -1) {
              const afterChecklist = body.substring(checklistIndex);
              const nextSectionMatch = afterChecklist.match(/\n\n---/);
              if (nextSectionMatch) {
                const checklistEndIndex = checklistIndex + nextSectionMatch.index;
                body = body.substring(0, checklistIndex) + checklistHeader + '\n\n' + checklistItems + body.substring(checklistEndIndex);
              }
            }

            // æ›´æ–° PRD issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: PRD_ISSUE,
              body: body,
            });

            console.log('âœ… PRD issue #176 çŠ¶æ€å·²æ›´æ–°');

            // è¾“å‡ºæ›´æ–°æ‘˜è¦
            const summary = issueStatuses.map(i => `#${i.number}: ${i.state}`).join(', ');
            core.summary.addHeading('PRD Status Update');
            core.summary.addRaw(`Updated PRD #${PRD_ISSUE} with latest sub-issue statuses: ${summary}`);
            await core.summary.write();
