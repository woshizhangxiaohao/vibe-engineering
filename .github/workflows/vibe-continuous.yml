name: Vibe Continuous - 24å°æ—¶è‡ªåŠ¨è¿­ä»£å¼•æ“

on:
  # æ¯å°æ—¶è¿è¡Œä¸€æ¬¡ï¼ŒæŒç»­æ£€æµ‹
  schedule:
    - cron: '0 * * * *'
  # æ”¯æŒæ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'æŒ‡å®šæ£€æµ‹çš„ Issue ç¼–å·ï¼ˆç•™ç©ºåˆ™æ£€æµ‹æ‰€æœ‰ï¼‰'
        required: false
        type: string
      mode:
        description: 'è¿è¡Œæ¨¡å¼'
        required: true
        default: 'scan'
        type: choice
        options:
          - scan        # æ‰«ææ‰€æœ‰è¿›è¡Œä¸­çš„ issue
          - check       # æ£€æµ‹æŒ‡å®š issue å®Œæˆåº¦
          - continue    # ç»§ç»­å¤„ç†æœªå®Œæˆä»»åŠ¡

jobs:
  continuous-iteration:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      pull-requests: read
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Scan and Continue Issues
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        with:
          script: |
            const fs = require('fs');
            const mode = '${{ github.event.inputs.mode }}' || 'scan';
            const specificIssue = '${{ github.event.inputs.issue_number }}';
            const now = new Date();

            console.log("=".repeat(60));
            console.log("ğŸ”„ VIBE CONTINUOUS - 24å°æ—¶è‡ªåŠ¨è¿­ä»£å¼•æ“");
            console.log("=".repeat(60));
            console.log(`æ—¶é—´: ${now.toISOString()}`);
            console.log(`æ¨¡å¼: ${mode}`);
            if (specificIssue) console.log(`æŒ‡å®š Issue: #${specificIssue}`);

            // è¯»å–é…ç½®
            let config;
            try {
              const configContent = fs.readFileSync('.github/config/workflow-config.json', 'utf8');
              config = JSON.parse(configContent);
            } catch (error) {
              console.warn(`âš ï¸ æ— æ³•è¯»å–é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
              config = {
                continuous: {
                  check_interval_hours: 1,
                  max_iterations_per_issue: 10,
                  completion_check_model: "google/gemini-2.0-flash-001"
                }
              };
            }

            // è·å–éœ€è¦æ£€æµ‹çš„ Issues
            async function getTargetIssues() {
              if (specificIssue) {
                const { data: issue } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parseInt(specificIssue)
                });
                return [issue];
              }

              // è·å–æ‰€æœ‰å¤„äºå¼€å‘ä¸­çš„ issue
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });

              // è¿‡æ»¤å‡ºéœ€è¦æ£€æµ‹çš„ issue
              // æ¡ä»¶ï¼šæœ‰éªŒæ”¶æ ‡å‡† + æœ‰ PR æˆ–æ­£åœ¨å¤„ç†ä¸­
              return issues.filter(issue => {
                const labels = issue.labels.map(l => l.name);
                const body = issue.body || '';

                // å¿…é¡»æœ‰éªŒæ”¶æ ‡å‡†
                const hasAcceptanceCriteria =
                  body.includes('éªŒæ”¶æ ‡å‡†') ||
                  body.includes('Acceptance Criteria') ||
                  body.includes('## âœ…') ||
                  body.includes('- [ ]');

                // å¿…é¡»æ˜¯è¿›è¡Œä¸­æˆ–å·²æœ‰ PR
                const isInProgress =
                  labels.includes('ğŸ¤– ai-processing') ||
                  labels.includes('âœ… ai-completed') ||
                  labels.some(l => l.includes('complexity:'));

                // æ’é™¤å·²å…³é—­å’Œè·³è¿‡çš„
                const shouldSkip =
                  labels.includes('skip-vibe') ||
                  labels.includes('needs-triage') ||
                  issue.title.startsWith('[PRD]');

                return hasAcceptanceCriteria && isInProgress && !shouldSkip;
              });
            }

            // è§£æéªŒæ”¶æ ‡å‡†
            function parseAcceptanceCriteria(body) {
              const criteria = [];
              const lines = body.split('\n');
              let inCriteriaSection = false;

              for (const line of lines) {
                // æ£€æµ‹éªŒæ”¶æ ‡å‡†åŒºå—
                if (line.includes('éªŒæ”¶æ ‡å‡†') || line.includes('Acceptance Criteria') || line.includes('## âœ…')) {
                  inCriteriaSection = true;
                  continue;
                }

                // é‡åˆ°æ–°çš„æ ‡é¢˜ç»“æŸåŒºå—
                if (inCriteriaSection && line.startsWith('## ') && !line.includes('âœ…')) {
                  inCriteriaSection = false;
                  continue;
                }

                // æå– checkbox é¡¹ç›®
                const checkboxMatch = line.match(/^[\s-]*\[([x ])\]\s*(.+)/i);
                if (checkboxMatch) {
                  criteria.push({
                    completed: checkboxMatch[1].toLowerCase() === 'x',
                    text: checkboxMatch[2].trim()
                  });
                }
              }

              // å¦‚æœæ²¡æ‰¾åˆ°ä¸“é—¨çš„éªŒæ”¶æ ‡å‡†åŒºå—ï¼Œæœç´¢æ•´ä¸ªæ–‡æ¡£çš„ checkbox
              if (criteria.length === 0) {
                const allCheckboxes = body.match(/\[([x ])\]\s*(.+)/gi) || [];
                for (const match of allCheckboxes) {
                  const m = match.match(/\[([x ])\]\s*(.+)/i);
                  if (m) {
                    criteria.push({
                      completed: m[1].toLowerCase() === 'x',
                      text: m[2].trim()
                    });
                  }
                }
              }

              return criteria;
            }

            // è·å– issue ç›¸å…³çš„ PR
            async function getRelatedPRs(issueNumber) {
              try {
                const { data: events } = await github.rest.issues.listEventsForTimeline({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber
                });

                const prNumbers = new Set();
                for (const event of events) {
                  if (event.event === 'cross-referenced' && event.source?.issue?.pull_request) {
                    prNumbers.add(event.source.issue.number);
                  }
                }

                const prs = [];
                for (const prNumber of prNumbers) {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  prs.push(pr);
                }

                return prs;
              } catch (error) {
                console.warn(`âš ï¸ è·å–å…³è” PR å¤±è´¥: ${error.message}`);
                return [];
              }
            }

            // æ£€æŸ¥ PR çš„ CI çŠ¶æ€
            async function getPRStatus(prNumber) {
              try {
                const { data: checks } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/pull/${prNumber}/head`
                });

                const status = {
                  total: checks.check_runs.length,
                  success: 0,
                  failure: 0,
                  pending: 0
                };

                for (const check of checks.check_runs) {
                  if (check.conclusion === 'success') status.success++;
                  else if (check.conclusion === 'failure') status.failure++;
                  else status.pending++;
                }

                return status;
              } catch (error) {
                return { total: 0, success: 0, failure: 0, pending: 0 };
              }
            }

            // ä½¿ç”¨ AI è¯„ä¼°å®Œæˆåº¦
            async function aiEvaluateCompletion(issue, criteria, prInfo) {
              const prompt = `
            ä½ æ˜¯ä¸€ä¸ªé¡¹ç›®éªŒæ”¶ä¸“å®¶ã€‚è¯·è¯„ä¼°ä»¥ä¸‹ GitHub Issue çš„å®Œæˆæƒ…å†µã€‚

            ## Issue ä¿¡æ¯
            æ ‡é¢˜: ${issue.title}
            æè¿°:
            ${issue.body?.substring(0, 2000) || 'æ— æè¿°'}

            ## éªŒæ”¶æ ‡å‡†
            ${criteria.map((c, i) => `${i + 1}. [${c.completed ? 'x' : ' '}] ${c.text}`).join('\n')}

            ## å…³è” PR ä¿¡æ¯
            ${prInfo || 'æš‚æ— å…³è” PR'}

            ## è¯·åˆ†æå¹¶è¿”å› JSON æ ¼å¼ï¼š
            {
              "completion_percentage": 0-100 çš„æ•°å­—,
              "completed_items": ["å·²å®Œæˆçš„å…·ä½“é¡¹ç›®"],
              "pending_items": ["æœªå®Œæˆçš„å…·ä½“é¡¹ç›®"],
              "blocking_issues": ["é˜»å¡é—®é¢˜"],
              "next_action": "å»ºè®®çš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨",
              "should_continue": true/false æ˜¯å¦éœ€è¦ç»§ç»­å¼€å‘,
              "agent_type": "simple/medium/complex" å¦‚æœéœ€è¦ç»§ç»­ï¼Œæ¨èçš„ agent ç±»å‹
            }
            `;

              try {
                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                  method: "POST",
                  headers: {
                    "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                    "Content-Type": "application/json",
                    "HTTP-Referer": "https://github.com/lessthanno/vibe-engineering-playbook",
                    "X-Title": "Vibe Continuous"
                  },
                  body: JSON.stringify({
                    model: config.continuous?.completion_check_model || "google/gemini-2.0-flash-001",
                    messages: [{ role: "user", content: prompt }],
                    temperature: 0.1,
                    response_format: { type: "json_object" }
                  })
                });

                if (!response.ok) {
                  throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status}`);
                }

                const data = await response.json();
                const content = data.choices?.[0]?.message?.content || '';
                const jsonMatch = content.match(/\{[\s\S]*\}/);

                if (jsonMatch) {
                  return JSON.parse(jsonMatch[0]);
                }
              } catch (error) {
                console.error(`AI è¯„ä¼°å¤±è´¥: ${error.message}`);
              }

              // å›é€€åˆ°åŸºäº checkbox çš„ç®€å•è¯„ä¼°
              const completed = criteria.filter(c => c.completed).length;
              const total = criteria.length;
              const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

              return {
                completion_percentage: percentage,
                completed_items: criteria.filter(c => c.completed).map(c => c.text),
                pending_items: criteria.filter(c => !c.completed).map(c => c.text),
                blocking_issues: [],
                next_action: percentage < 100 ? "ç»§ç»­å®Œæˆæœªå®ç°çš„åŠŸèƒ½" : "å‡†å¤‡åˆå¹¶",
                should_continue: percentage < 100,
                agent_type: "medium"
              };
            }

            // è§¦å‘ Agent ç»§ç»­å¤„ç†
            async function triggerContinuation(issue, evaluation) {
              // æ£€æŸ¥è¿­ä»£æ¬¡æ•°é™åˆ¶
              const iterationMatch = issue.body?.match(/<!-- vibe-iteration: (\d+) -->/);
              const currentIteration = iterationMatch ? parseInt(iterationMatch[1]) : 0;
              const maxIterations = config.continuous?.max_iterations_per_issue || 10;

              if (currentIteration >= maxIterations) {
                console.log(`âš ï¸ Issue #${issue.number} å·²è¾¾æœ€å¤§è¿­ä»£æ¬¡æ•° (${maxIterations})`);

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    "âš ï¸ **è‡ªåŠ¨è¿­ä»£å·²è¾¾ä¸Šé™**",
                    "",
                    `æ­¤ä»»åŠ¡å·²è‡ªåŠ¨è¿­ä»£ ${maxIterations} æ¬¡ï¼Œéœ€è¦äººå·¥ä»‹å…¥ã€‚`,
                    "",
                    `**å½“å‰å®Œæˆåº¦**: ${evaluation.completion_percentage}%`,
                    "",
                    "**æœªå®Œæˆé¡¹ç›®**:",
                    evaluation.pending_items.map(p => `- ${p}`).join('\n'),
                    "",
                    "---",
                    "> ğŸ” ç”± Vibe Continuous æ£€æµ‹"
                  ].join("\n")
                });

                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-review', 'âš ï¸ iteration-limit']
                });

                return false;
              }

              // æ„å»ºç»§ç»­å¤„ç†çš„æŒ‡ä»¤
              const continuationPrompt = [
                `## ğŸ”„ è‡ªåŠ¨è¿­ä»£ #${currentIteration + 1}`,
                "",
                "**å®Œæˆåº¦æ£€æµ‹ç»“æœ**:",
                `- å½“å‰è¿›åº¦: ${evaluation.completion_percentage}%`,
                `- å·²å®Œæˆ: ${evaluation.completed_items.length} é¡¹`,
                `- å¾…å®Œæˆ: ${evaluation.pending_items.length} é¡¹`,
                "",
                "**å¾…å®Œæˆé¡¹ç›®**:",
                evaluation.pending_items.map(p => `- [ ] ${p}`).join('\n'),
                "",
                "**ä¸‹ä¸€æ­¥è¡ŒåŠ¨**:",
                evaluation.next_action,
                "",
                "---",
                "",
                `/${evaluation.agent_type === 'simple' ? 'agent-simple' : evaluation.agent_type === 'complex' ? 'agent-complex' : 'agent-medium'}`,
                "",
                "---",
                "> ğŸ”„ ç”± Vibe Continuous è‡ªåŠ¨è§¦å‘"
              ].join("\n");

              // æ›´æ–° issue body ä¸­çš„è¿­ä»£è®¡æ•°
              const newBody = issue.body?.includes('<!-- vibe-iteration:')
                ? issue.body.replace(/<!-- vibe-iteration: \d+ -->/, `<!-- vibe-iteration: ${currentIteration + 1} -->`)
                : `${issue.body || ''}\n\n<!-- vibe-iteration: ${currentIteration + 1} -->`;

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: newBody
              });

              // å‘å¸ƒç»§ç»­å¤„ç†çš„è¯„è®º
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: continuationPrompt
              });

              console.log(`âœ… å·²è§¦å‘ Issue #${issue.number} ç»§ç»­è¿­ä»£ (ç¬¬ ${currentIteration + 1} æ¬¡)`);
              return true;
            }

            // ä¸»é€»è¾‘
            const targetIssues = await getTargetIssues();
            console.log(`\nğŸ“‹ æ‰¾åˆ° ${targetIssues.length} ä¸ªéœ€è¦æ£€æµ‹çš„ Issue\n`);

            const results = {
              checked: 0,
              completed: 0,
              continued: 0,
              skipped: 0
            };

            for (const issue of targetIssues) {
              console.log(`\n${"â”€".repeat(50)}`);
              console.log(`ğŸ“Œ Issue #${issue.number}: ${issue.title}`);

              // è§£æéªŒæ”¶æ ‡å‡†
              const criteria = parseAcceptanceCriteria(issue.body || '');
              if (criteria.length === 0) {
                console.log(`  â­ï¸ è·³è¿‡: æ— å¯è¯†åˆ«çš„éªŒæ”¶æ ‡å‡†`);
                results.skipped++;
                continue;
              }

              console.log(`  ğŸ“‹ éªŒæ”¶æ ‡å‡†: ${criteria.length} é¡¹`);
              console.log(`  âœ… å·²å®Œæˆ: ${criteria.filter(c => c.completed).length} é¡¹`);

              // è·å–å…³è” PR
              const relatedPRs = await getRelatedPRs(issue.number);
              let prInfo = '';

              if (relatedPRs.length > 0) {
                const prDetails = [];
                for (const pr of relatedPRs) {
                  const status = await getPRStatus(pr.number);
                  prDetails.push(`PR #${pr.number}: ${pr.state} (CI: ${status.success}/${status.total} é€šè¿‡)`);
                }
                prInfo = prDetails.join('\n');
                console.log(`  ğŸ”— å…³è” PR: ${relatedPRs.length} ä¸ª`);
              }

              // AI è¯„ä¼°å®Œæˆåº¦
              const evaluation = await aiEvaluateCompletion(issue, criteria, prInfo);
              console.log(`  ğŸ“Š AI è¯„ä¼°å®Œæˆåº¦: ${evaluation.completion_percentage}%`);
              results.checked++;

              // åˆ¤æ–­æ˜¯å¦éœ€è¦ç»§ç»­
              if (evaluation.completion_percentage >= 100) {
                console.log(`  âœ… ä»»åŠ¡å·²å®Œæˆï¼`);
                results.completed++;

                // æ·»åŠ å®Œæˆæ ‡ç­¾
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['âœ… verified']
                });

              } else if (evaluation.should_continue && mode !== 'check') {
                // è§¦å‘ç»§ç»­è¿­ä»£
                const triggered = await triggerContinuation(issue, evaluation);
                if (triggered) results.continued++;
              } else {
                console.log(`  â„¹ï¸ å®Œæˆåº¦: ${evaluation.completion_percentage}% (æ¨¡å¼: ${mode})`);
              }
            }

            // è¾“å‡ºæ±‡æ€»
            console.log("\n" + "=".repeat(60));
            console.log("ğŸ“Š æ£€æµ‹ç»“æœæ±‡æ€»");
            console.log("=".repeat(60));
            console.log(`  æ£€æµ‹: ${results.checked} ä¸ª`);
            console.log(`  å·²å®Œæˆ: ${results.completed} ä¸ª`);
            console.log(`  ç»§ç»­è¿­ä»£: ${results.continued} ä¸ª`);
            console.log(`  è·³è¿‡: ${results.skipped} ä¸ª`);
