name: Vibe Monitor - ä»»åŠ¡ç›‘æ§ä¸è‡ªåŠ¨æ¢å¤

on:
  # æ¯å°æ—¶è¿è¡Œä¸€æ¬¡
  schedule:
    - cron: '0 * * * *'
  # æ”¯æŒæ‰‹åŠ¨è§¦å‘
  workflow_dispatch:
    inputs:
      action:
        description: 'æ‰§è¡Œæ“ä½œ'
        required: true
        default: 'check'
        type: choice
        options:
          - check       # ä»…æ£€æŸ¥çŠ¶æ€
          - retry-failed # é‡è¯•å¤±è´¥ä»»åŠ¡
          - clean-stale  # æ¸…ç†è¶…æ—¶ä»»åŠ¡

jobs:
  monitor:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Monitor and Recover
        uses: actions/github-script@v7
        with:
          script: |
            const action = '${{ github.event.inputs.action }}' || 'check';
            const now = new Date();

            console.log("=".repeat(60));
            console.log("ğŸ” VIBE MONITOR - ä»»åŠ¡ç›‘æ§");
            console.log("=".repeat(60));
            console.log(`æ—¶é—´: ${now.toISOString()}`);
            console.log(`æ“ä½œ: ${action}`);

            // è·å–æ‰€æœ‰æ‰“å¼€çš„ Issue
            const { data: allIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            // åˆ†ç±»ç»Ÿè®¡
            const stats = {
              processing: [],
              failed: [],
              stale: [],
              pending: [],
              completed: 0
            };

            // é˜ˆå€¼é…ç½®
            const STALE_HOURS = 4;  // è¶…è¿‡4å°æ—¶æœªæ›´æ–°è§†ä¸ºè¶…æ—¶
            const RETRY_LIMIT = 3; // æœ€å¤§é‡è¯•æ¬¡æ•°

            for (const issue of allIssues) {
              const labels = issue.labels.map(l => l.name);
              const updatedAt = new Date(issue.updated_at);
              const hoursSinceUpdate = (now - updatedAt) / (1000 * 60 * 60);

              if (labels.includes('ğŸ¤– ai-processing')) {
                if (hoursSinceUpdate > STALE_HOURS) {
                  stats.stale.push({ issue, hoursSinceUpdate });
                } else {
                  stats.processing.push({ issue, hoursSinceUpdate });
                }
              } else if (labels.includes('âŒ ai-failed')) {
                // æ£€æŸ¥é‡è¯•æ¬¡æ•°
                const retryMatch = issue.body?.match(/Retry count: (\d+)/);
                const retryCount = retryMatch ? parseInt(retryMatch[1]) : 0;
                stats.failed.push({ issue, retryCount });
              } else if (labels.some(l => l.startsWith('complexity:'))) {
                // æœ‰å¤æ‚åº¦æ ‡ç­¾ä½†æœªå¤„ç†
                stats.pending.push({ issue });
              }
            }

            console.log("\nğŸ“Š ä»»åŠ¡çŠ¶æ€æ±‡æ€»:");
            console.log(`  - å¤„ç†ä¸­: ${stats.processing.length}`);
            console.log(`  - å·²è¶…æ—¶: ${stats.stale.length}`);
            console.log(`  - å·²å¤±è´¥: ${stats.failed.length}`);
            console.log(`  - å¾…å¤„ç†: ${stats.pending.length}`);

            // æ‰§è¡Œæ¸…ç†è¶…æ—¶ä»»åŠ¡
            if (action === 'clean-stale' || action === 'check') {
              for (const { issue, hoursSinceUpdate } of stats.stale) {
                console.log(`âš ï¸ è¶…æ—¶ä»»åŠ¡ #${issue.number}: ${issue.title} (${hoursSinceUpdate.toFixed(1)}h)`);

                if (action === 'clean-stale') {
                  // ç§»é™¤ processing æ ‡ç­¾
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: 'ğŸ¤– ai-processing'
                    });
                  } catch (e) {}

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['âš ï¸ stale', 'needs-review']
                  });

                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: [
                      "âš ï¸ **ä»»åŠ¡è¶…æ—¶**",
                      "",
                      `æ­¤ä»»åŠ¡å·²è¶…è¿‡ ${STALE_HOURS} å°æ—¶æœªæ›´æ–°ï¼Œå·²è‡ªåŠ¨æ ‡è®°ä¸ºè¶…æ—¶ã€‚`,
                      "",
                      "**å¯èƒ½çš„åŸå› :**",
                      "- Workflow æ‰§è¡Œæ—¶é—´è¿‡é•¿",
                      "- API è°ƒç”¨å¤±è´¥",
                      "- Workflow è¢«å–æ¶ˆ",
                      "",
                      "**è§£å†³æ–¹æ¡ˆ:**",
                      "- æŸ¥çœ‹ Actions æ—¥å¿—ç¡®è®¤çŠ¶æ€",
                      "- ä½¿ç”¨å¯¹åº”çš„ `/agent-*` å‘½ä»¤é‡è¯•",
                      "",
                      "---",
                      "> ğŸ” ç”± Vibe Monitor è‡ªåŠ¨æ£€æµ‹"
                    ].join("\n")
                  });
                }
              }
            }

            // æ‰§è¡Œé‡è¯•å¤±è´¥ä»»åŠ¡
            if (action === 'retry-failed') {
              for (const { issue, retryCount } of stats.failed) {
                if (retryCount >= RETRY_LIMIT) {
                  console.log(`â­ï¸ è·³è¿‡ #${issue.number}: å·²è¾¾é‡è¯•ä¸Šé™ (${retryCount}/${RETRY_LIMIT})`);
                  continue;
                }

                console.log(`ğŸ”„ é‡è¯• #${issue.number}: ${issue.title}`);

                // ç¡®å®šä»»åŠ¡å¤æ‚åº¦
                const labels = issue.labels.map(l => l.name);
                let agentCommand = '/agent-medium';  // é»˜è®¤ä¸­ç­‰

                if (labels.includes('complexity:simple') || labels.includes('agent:simple')) {
                  agentCommand = '/agent-simple';
                } else if (labels.includes('complexity:complex') || labels.includes('agent:complex')) {
                  agentCommand = '/agent-complex';
                }

                // ç§»é™¤å¤±è´¥æ ‡ç­¾
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: 'âŒ ai-failed'
                  });
                } catch (e) {}

                // æ·»åŠ é‡è¯•è¯„è®º
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    `${agentCommand}`,
                    "",
                    "---",
                    "",
                    `ğŸ”„ **è‡ªåŠ¨é‡è¯•** (${retryCount + 1}/${RETRY_LIMIT})`,
                    "",
                    "> ç”± Vibe Monitor è‡ªåŠ¨è§¦å‘é‡è¯•"
                  ].join("\n")
                });

                // æ›´æ–° issue body ä¸­çš„é‡è¯•è®¡æ•°
                const newBody = issue.body?.includes('Retry count:')
                  ? issue.body.replace(/Retry count: \d+/, `Retry count: ${retryCount + 1}`)
                  : `${issue.body || ''}\n\n---\nRetry count: ${retryCount + 1}`;

                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: newBody
                });
              }
            }

            // ç”ŸæˆæŠ¥å‘Š
            if (stats.stale.length > 0 || stats.failed.length > 0) {
              console.log("\nğŸ“‹ éœ€è¦å…³æ³¨çš„ä»»åŠ¡:");
              for (const { issue } of stats.stale) {
                console.log(`  âš ï¸ #${issue.number}: ${issue.title} (è¶…æ—¶)`);
              }
              for (const { issue, retryCount } of stats.failed) {
                console.log(`  âŒ #${issue.number}: ${issue.title} (å¤±è´¥, é‡è¯•${retryCount}æ¬¡)`);
              }
            } else {
              console.log("\nâœ… æ‰€æœ‰ä»»åŠ¡çŠ¶æ€æ­£å¸¸");
            }

      - name: Create Daily Summary (æ¯æ—¥8ç‚¹)
        if: github.event.schedule == '0 0 * * *'
        uses: actions/github-script@v7
        with:
          script: |
            // è·å–è¿‡å»24å°æ—¶çš„ç»Ÿè®¡
            const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);

            const { data: closedIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              since: yesterday.toISOString(),
              per_page: 100
            });

            const aiCompleted = closedIssues.filter(i =>
              i.labels.some(l => l.name === 'âœ… ai-completed')
            );

            if (aiCompleted.length > 0) {
              console.log(`ğŸ“Š è¿‡å»24å°æ—¶ AI å®Œæˆäº† ${aiCompleted.length} ä¸ªä»»åŠ¡`);
            }
