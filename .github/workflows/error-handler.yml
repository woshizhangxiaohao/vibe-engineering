name: Error Handler

on:
  workflow_run:
    workflows:
      - "Backend Agent"
      - "Vibe Frontend Agent"
      - "Vibe UI Agent"
    types:
      - completed

  # æ‰‹åŠ¨è§¦å‘æµ‹è¯•
  workflow_dispatch:
    inputs:
      run_id:
        description: 'è¦åˆ†æçš„ workflow run ID'
        required: true
        type: string
      test_mode:
        description: 'æµ‹è¯•æ¨¡å¼ï¼ˆä¸è§¦å‘è‡ªåŠ¨ä¿®å¤ï¼‰'
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write
  actions: read
  issues: write

jobs:
  handle-errors:
    # è‡ªåŠ¨è§¦å‘æ—¶åªå¤„ç†å¤±è´¥çš„ workflowï¼Œæ‰‹åŠ¨è§¦å‘æ—¶æ€»æ˜¯è¿è¡Œ
    if: github.event.workflow_run.conclusion == 'failure' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    steps:
      - name: Collect Error Info and Analyze
        id: analyze
        uses: actions/github-script@v7
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        with:
          script: |
            // æ”¯æŒæ‰‹åŠ¨è§¦å‘å’Œè‡ªåŠ¨è§¦å‘ä¸¤ç§æ¨¡å¼
            const isManualTrigger = context.eventName === 'workflow_dispatch';
            const runId = isManualTrigger
              ? parseInt('${{ inputs.run_id }}')
              : context.payload.workflow_run.id;

            console.log(`ğŸ“‹ åˆ†æ Workflow Run: ${runId}`);

            // è·å– workflow run ä¿¡æ¯
            const runData = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            const run = runData.data;

            // æŸ¥æ‰¾å…³è”çš„ Issue
            let issueNumber = null;
            const branchMatch = run.head_branch?.match(/issue-(\d+)/);
            if (branchMatch) {
              issueNumber = parseInt(branchMatch[1]);
            }
            if (!issueNumber && run.pull_requests && run.pull_requests.length > 0) {
              issueNumber = run.pull_requests[0].number;
            }

            // è·å–å¤±è´¥çš„ jobs å’Œæ—¥å¿—
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            const failedJobs = jobs.data.jobs.filter(job => job.conclusion === 'failure');
            console.log(`âŒ å¤±è´¥çš„ Jobs: ${failedJobs.map(j => j.name).join(', ')}`);

            // è·å–æ¯ä¸ªå¤±è´¥ job çš„æ—¥å¿—ï¼ˆæˆªå–æœ€åéƒ¨åˆ†ï¼‰
            let errorLogs = [];
            for (const job of failedJobs.slice(0, 2)) {
              try {
                const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  job_id: job.id
                });
                // åªä¿ç•™æœ€å 100 è¡Œï¼Œé¿å…å¤ªé•¿
                const logLines = logs.data.split('\n').slice(-100).join('\n');
                errorLogs.push({
                  jobName: job.name,
                  logs: logLines.substring(0, 5000)
                });
              } catch (e) {
                errorLogs.push({ jobName: job.name, logs: 'Failed to fetch logs' });
              }
            }

            // æ„å»ºé”™è¯¯ä¿¡æ¯
            const errorInfo = {
              issueNumber,
              runId: run.id,
              runUrl: run.html_url,
              workflowName: run.name,
              headBranch: run.head_branch,
              event: run.event,
              failedJobs: failedJobs.map(j => j.name),
              errorLogs
            };

            // æ„å»º prompt
            const prompt = `ä½ æ˜¯ä¸€ä¸ª CI/CD é”™è¯¯åˆ†æä¸“å®¶ã€‚è¯·åˆ†æä»¥ä¸‹ GitHub Actions workflow å¤±è´¥çš„åŸå› ï¼Œå¹¶æä¾›ç®€æ´çš„åˆ†ææŠ¥å‘Šã€‚

            ## Workflow ä¿¡æ¯
            - Workflow: ${errorInfo.workflowName}
            - Branch: ${errorInfo.headBranch}
            - å¤±è´¥çš„ Jobs: ${errorInfo.failedJobs.join(', ')}

            ## é”™è¯¯æ—¥å¿—
            ${JSON.stringify(errorInfo.errorLogs, null, 2)}

            è¯·è¾“å‡ºä»¥ä¸‹æ ¼å¼çš„åˆ†ææŠ¥å‘Šï¼ˆä½¿ç”¨ä¸­æ–‡ï¼‰ï¼š

            ## ğŸ” é”™è¯¯åˆ†æ

            ### æ ¹æœ¬åŸå› 
            [ä¸€å¥è¯æè¿°æ ¹æœ¬åŸå› ]

            ### é”™è¯¯ç±»å‹
            [é€‰æ‹©ä¸€ä¸ª: é…ç½®é—®é¢˜ | ä»£ç é”™è¯¯ | è¾“å…¥ç¼ºå¤± | æƒé™é—®é¢˜ | ä¸´æ—¶æ•…éšœ | å…¶ä»–]

            ### è¯¦ç»†è¯´æ˜
            [2-3å¥è¯è¯¦ç»†è§£é‡Šé—®é¢˜]

            ### å»ºè®®ä¿®å¤æ–¹æ¡ˆ
            [åˆ—å‡º1-3ä¸ªå…·ä½“çš„ä¿®å¤æ­¥éª¤]

            ### æ˜¯å¦å¯è‡ªåŠ¨ä¿®å¤
            [æ˜¯/å¦] - [åŸå› ]`;

            // è°ƒç”¨ OpenRouter API
            let analysis = '_AI åˆ†ææš‚ä¸å¯ç”¨_';
            try {
              console.log('ğŸ¤– è°ƒç”¨ Claude API è¿›è¡Œåˆ†æ...');
              const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`
                },
                body: JSON.stringify({
                  model: 'anthropic/claude-sonnet-4',
                  messages: [{ role: 'user', content: prompt }],
                  max_tokens: 1500
                })
              });

              const data = await response.json();
              if (data.choices && data.choices[0] && data.choices[0].message) {
                analysis = data.choices[0].message.content;
                console.log('âœ… AI åˆ†æå®Œæˆ');
              } else {
                console.log('âš ï¸ API å“åº”æ ¼å¼å¼‚å¸¸:', JSON.stringify(data).substring(0, 500));
              }
            } catch (e) {
              console.log('âŒ API è°ƒç”¨å¤±è´¥:', e.message);
            }

            // æ„å»ºæŠ¥å‘Š
            const reportBody = [
              "## âŒ Workflow æ‰§è¡Œå¤±è´¥",
              "",
              `**Workflow:** ${errorInfo.workflowName}`,
              `**è¿è¡Œ ID:** ${errorInfo.runId}`,
              `**è§¦å‘åˆ†æ”¯:** ${errorInfo.headBranch}`,
              `**è§¦å‘äº‹ä»¶:** ${errorInfo.event}`,
              "",
              "### å¤±è´¥çš„ Jobs:",
              ...errorInfo.failedJobs.map(job => `- **${job}**`),
              "",
              `ğŸ”— [æŸ¥çœ‹å®Œæ•´æ—¥å¿—](${errorInfo.runUrl})`,
              "",
              "---",
              "",
              analysis,
              "",
              "---",
              "_è‡ªåŠ¨ç”Ÿæˆ - Error Handler with AI Analysis_"
            ].join("\n");

            // å‘å¸ƒåˆ° Issue
            if (errorInfo.issueNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: errorInfo.issueNumber,
                body: reportBody
              });

              // æ›´æ–°æ ‡ç­¾
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: errorInfo.issueNumber,
                name: 'ğŸ¤– ai-processing'
              }).catch(() => {});

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: errorInfo.issueNumber,
                labels: ['âŒ ai-failed', 'ğŸ” analyzed']
              });

              console.log(`âœ… å·²è¯„è®ºåˆ° Issue #${errorInfo.issueNumber}`);
              core.setOutput('target_issue', errorInfo.issueNumber);
            } else {
              // åˆ›å»ºæ–° Issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[Auto] Workflow å¤±è´¥: ${errorInfo.workflowName}`,
                body: reportBody,
                labels: ['ğŸ› bug', 'ğŸ¤– auto-generated', 'workflow-failure', 'ğŸ” analyzed']
              });

              console.log(`âœ… å·²åˆ›å»º Issue #${newIssue.data.number}`);
              core.setOutput('target_issue', newIssue.data.number);
            }

            // åˆ¤æ–­æ˜¯å¦å¯ä»¥è‡ªåŠ¨ä¿®å¤
            const canAutoFix = analysis.includes('ä»£ç é”™è¯¯') &&
                               analysis.includes('æ˜¯å¦å¯è‡ªåŠ¨ä¿®å¤') &&
                               !analysis.includes('å¦ -') &&
                               !analysis.includes('è¾“å…¥ç¼ºå¤±') &&
                               !analysis.includes('é…ç½®é—®é¢˜');

            core.setOutput('can_auto_fix', canAutoFix);
            core.setOutput('issue_number', errorInfo.issueNumber || '');
            core.setOutput('workflow_name', errorInfo.workflowName);

            return { errorInfo, analysis, canAutoFix };

      - name: Trigger Auto-Fix (if applicable)
        if: steps.analyze.outputs.can_auto_fix == 'true' && inputs.test_mode != true
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = '${{ steps.analyze.outputs.issue_number }}';
            const workflowName = '${{ steps.analyze.outputs.workflow_name }}';

            if (!issueNumber) {
              console.log('âš ï¸ æ— å…³è” Issueï¼Œè·³è¿‡è‡ªåŠ¨ä¿®å¤');
              return;
            }

            // è§¦å‘ fix-pr workflow
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'fix-pr.yml',
                ref: 'main',
                inputs: {
                  pr_number: issueNumber,
                  error_context: `Workflow ${workflowName} failed. Check issue for AI analysis.`
                }
              });

              // è¯„è®ºé€šçŸ¥
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber),
                body: 'ğŸ”§ **æ­£åœ¨å°è¯•è‡ªåŠ¨ä¿®å¤...** è¯·ç¨å€™æŸ¥çœ‹ç»“æœã€‚'
              });

              console.log('âœ… å·²è§¦å‘è‡ªåŠ¨ä¿®å¤');
            } catch (e) {
              console.log('âŒ æ— æ³•è§¦å‘è‡ªåŠ¨ä¿®å¤:', e.message);
            }
